4o总结

### 8.2 进程的创建和终止

------

#### 8.2.1 写时复制技术

写时复制（Copy On Write, COW）是一种在创建新进程时优化内存资源的技术。传统的 UNIX 系统在创建进程时会复制父进程的所有资源，导致效率低下。写时复制技术优化了这一过程：在创建子进程时，只复制父进程的页表，而不复制物理页面的内容。只有在父进程或子进程试图修改共享页面时，才会触发复制操作。这大大减少了创建子进程的内存开销。

------

#### 8.2.2 fork()函数

`fork()` 是 POSIX 标准中定义的最基本的进程创建函数。调用 `fork()` 函数时，操作系统会创建一个与父进程几乎相同的子进程。父子进程的区别在于它们的 PID 不同，子进程不会继承父进程的内存锁、定时器和信号量等。
`fork()` 函数的实现调用了 Linux 内核的 `_do_fork()` 函数。

```
c复制代码SYSCALL_DEFINE0(fork) {
    return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);
}
```

`fork()` 的实现只使用了 `SIGCHLD` 标志，表示子进程终止后会通知父进程。

------

#### 8.2.3 vfork()函数

`vfork()` 函数在创建子进程后，会挂起父进程直到子进程执行 `execve()` 或 `exit()`。这是为了解决 `fork()` 创建后立即执行 `execve()` 导致的内存浪费问题。`vfork()` 使用了额外的标志位 `CLONE_VFORK` 和 `CLONE_VM` 来共享进程地址空间，并阻塞父进程直到子进程完成。

```
c复制代码SYSCALL_DEFINE0(vfork) {
    return _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0, 0, NULL, NULL, 0);
}
```

------

#### 8.2.4 clone()函数

`clone()` 函数被设计为创建用户线程的主要接口。通过传递不同的标志位，`clone()` 可以实现不同的资源共享模式，例如共享地址空间、文件描述符表等。它的定义如下：

```
c复制代码#include <sched.h>
int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);
```

通过 `clone()`，Linux 能够使用线程和进程来进行任务管理。`clone()` 的实现同样依赖于 `_do_fork()` 函数。

------

#### 8.2.5 内核线程

内核线程是运行在内核地址空间中的特殊进程。它们没有独立的用户态地址空间，通常通过 `kthread_create()` 函数创建，并需要调用 `wake_up_process()` 函数将其唤醒。内核线程共享内核地址空间，主要用于完成操作系统的内部任务。

------

#### 8.2.6 _do_fork()函数

`fork()`、`vfork()` 和 `clone()` 均调用 `_do_fork()` 函数。此函数负责复制父进程的资源和创建子进程的 `task_struct` 结构。

```
c复制代码long _do_fork(unsigned long clone_flags, unsigned long stack_start,
              unsigned long stack_size, int __user *parent_tidptr,
              int __user *child_tidptr, unsigned long tls);
```

- `clone_flags`：标志位集合，用于控制资源共享。
- `stack_start` 和 `stack_size`：用于定义用户态栈的起始地址和大小。
- `parent_tidptr` 和 `child_tidptr`：用于指向父子进程的 TID。
- `tls`：设置线程本地存储（TLS）参数。

------

#### 8.2.7 终止进程

进程终止的方式有两种：主动终止（例如 `exit()` 调用或从 `main()` 返回）和被动终止（例如接收到终止信号）。进程的终止信息会通过 `wait()` 系列系统调用传递给父进程，内核会清理进程的资源。

------

#### 8.2.8 僵尸进程和托孤进程

当进程调用 `exit()` 函数后，会进入僵尸状态，等待父进程通过 `wait()` 系列函数获取终止信息。此时，子进程的资源已经被回收，只有 `task_struct` 保留，直到父进程获取信息后才会被销毁。

托孤进程指的是父进程先于子进程终止的情况。此时，子进程会由 `init` 进程接管。

------

#### 8.2.9 进程0和进程1

进程0（`idle` 进程）是系统创建的第一个进程，负责在没有其他进程运行时让 CPU 进入空闲状态。进程1（`init` 进程）则负责初始化系统配置，创建用户环境。`init` 进程在启动后会执行用户态的 `init` 程序，并根据 `/etc/inittab` 文件的配置启动系统服务。





expert总结

### 8.2 进程的创建和终止

POSIX标准定义了一些用于进程创建和终止的系统原语，包括`fork()`、`execve()`、`wait()`、`waitpid()`、`kill()`以及`exit()`等函数。Linux在实现中进行了扩展，引入了`vfork()`和`clone()`，以提高进程创建的效率。以下详细解析了各函数的机制、实现以及其在Linux内核中的处理过程。

------

#### 8.2.1 写时复制技术

在传统UNIX系统中，`fork()`创建的子进程会完整复制父进程的内存资源，导致效率低下。写时复制(COW)技术的引入使得子进程在创建时仅共享父进程的内存，只有在需要写入时才真正复制内存页。

- **机制**：在使用COW技术时，父子进程共享相同的物理内存。当进程尝试修改内存时，触发缺页异常，再将该内存页复制，确保双方拥有各自的副本。
- **效果**：显著减少进程创建的内存开销，提高系统效率。

##### COW示例图解

- **写前共享**：子进程和父进程共享同一页。
- **写后分离**：当子进程需要写入时，复制页面并分配新的物理页帧。

------

#### 8.2.2 `fork()`函数

`fork()`是POSIX定义的最基本的进程创建函数，通过调用`_do_fork()`系统调用实现。父进程在调用`fork()`后，创建一个子进程。子进程拥有与父进程相似的环境，但使用不同的PID。

```
pid_t fork(void); // 定义在 C 库中
```

- **返回值**：`fork()`会返回两次。对于父进程，返回子进程的PID；对于子进程，返回0。
- 差异：
  - 子进程和父进程有独立的ID。
  - 子进程不会继承父进程的内存锁、信号处理等信息。

在Linux内核中，`fork()`实现如下：

```
SYSCALL_DEFINE0(fork) {
    return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);
}
```

------

#### 8.2.3 `vfork()`函数

`vfork()`与`fork()`类似，但在子进程调用`execve()`或`exit()`之前，父进程会一直阻塞等待，以避免复制内存页表的开销。

- **定义**：

  ```
  pid_t vfork(void);
  ```

- **实现**：在内核中，`vfork()`通过`_do_fork()`实现，增加了`CLONE_VFORK`和`CLONE_VM`标志，表示父进程挂起并与子进程共享地址空间。

```
SYSCALL_DEFINE0(vfork) {
    return _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0, 0, NULL, NULL, 0);
}
```

------

#### 8.2.4 `clone()`函数

`clone()`是Linux提供的强大函数，用于创建线程或进程。`clone()`允许选择性地继承父进程的资源，通过多种标志灵活控制创建的线程或进程的属性。

```
int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);
```

- **参数说明**：
  - `fn`：子进程/线程执行的函数。
  - `child_stack`：子进程/线程的栈起始地址。
  - `flags`：标志位，用于设置共享资源。
  - `arg`：传递给子进程/线程的参数。
- **实现**：通过系统调用`_do_fork()`实现。

```
SYSCALL_DEFINE5(clone, unsigned long, clone_flags,
                unsigned long, newsp,
                int __user *, parent_tidptr,
                int __user *, child_tidptr,
                unsigned long, tls) {
    return _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);
}
```

- 常用标志位

  ：

  - `CLONE_VM`：共享地址空间。
  - `CLONE_FS`：共享文件系统信息。
  - `CLONE_FILES`：共享打开的文件。
  - `CLONE_SIGHAND`：共享信号处理。
  - `CLONE_THREAD`：在同一个线程组中。

------

#### 8.2.5 内核线程

内核线程是运行在内核空间中的特殊进程，与用户进程不同，它没有独立的地址空间。内核线程用于完成系统任务，如`kswapd`等。

```
// 创建内核线程的接口
kthread_create(threadfn, data, namefmt, arg...);
kthread_run(threadfn, data, namefmt, ...);
```

------

#### 8.2.6 `_do_fork()`函数

`_do_fork()`是`fork()`、`vfork()`和`clone()`的核心实现函数。它创建子进程的`task_struct`，并复制父进程的必要信息到子进程。

```
long _do_fork(unsigned long clone_flags, unsigned long stack_start,
              unsigned long stack_size, int __user *parent_tidptr,
              int __user *child_tidptr, unsigned long tls) {
    // 通过 copy_process 函数创建子进程的 task_struct
}
```

- 参数说明：
  - `clone_flags`：标志位。
  - `stack_start`：栈起始地址。
  - `parent_tidptr`：父进程ID指针。
  - `child_tidptr`：子进程ID指针。
  - `tls`：传递的TLS参数。

------

#### 8.2.7 终止进程

进程的终止分为主动和被动两种方式。

- **主动终止**：
  - `main()`函数返回时调用`exit()`。
  - 主动调用`exit()`系统调用。
- **被动终止**：
  - 接收到无法处理的信号。
  - 内核态产生异常。
  - 接收`SIGKILL`等信号。

当进程终止时，Linux内核会释放资源并通知父进程。`exit()`系统调用会将退出码转换成特定格式，并调用`do_exit()`来完成进程的终止操作。

------

#### 8.2.8 僵尸进程和托孤进程

- **僵尸进程**：当进程通过`exit()`终止后，会进入僵尸状态，保留`task_struct`以记录终止原因。父进程通过`wait()`系统调用获取信息后，内核才会释放`task_struct`。

  ```
  asmlinkage long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);
  ```

- **托孤进程**：如果父进程先于子进程终止，子进程会成为孤儿进程并交由`init`进程接管。

------

#### 8.2.9 进程0和进程1

- **进程0**：Linux内核在初始化阶段创建的内核线程，作为所有进程的祖先，别名包括`idle`进程、`swapper`进程。进程0的描述符在`init_task.c`中静态初始化。

  ```
  struct task_struct init_task = {
      .state = 0,
      .stack = init_stack,
      .active_mm = &init_mm,
  };
  ```

- **进程1**：内核启动后创建的第一个用户进程，负责初始化系统配置和启动用户登录界面。`init`进程从内核线程转为普通进程，通过`execve()`加载`/sbin/init`或`/bin/sh`，在SMP系统中，每个CPU都有一个独立的`idle`进程。

------

以上是8.2节关于进程创建和终止的详细总结与实现细节的完整说明。