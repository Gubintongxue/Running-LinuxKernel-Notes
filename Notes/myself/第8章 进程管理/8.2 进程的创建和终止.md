### 8.2 进程的创建和终止

POSIX标准定义了一些用于进程创建和终止的系统原语，包括`fork()`、`execve()`、`wait()`、`waitpid()`、`kill()`以及`exit()`等函数。Linux在实现中进行了扩展，引入了`vfork()`和`clone()`，以提高进程创建的效率。以下详细解析了各函数的机制、实现以及其在Linux内核中的处理过程。

------

#### 8.2.1 写时复制技术

在传统UNIX系统中，`fork()`创建的子进程会完整复制父进程的内存资源，导致效率低下。写时复制(COW)技术的引入使得子进程在创建时仅共享父进程的内存，只有在需要写入时才真正复制内存页。

- **机制**：在使用COW技术时，父子进程共享相同的物理内存。当进程尝试修改内存时，触发缺页异常，再将该内存页复制，确保双方拥有各自的副本。
- **效果**：显著减少进程创建的内存开销，提高系统效率。

##### COW示例图解

- **写前共享**：==子进程和父进程共享同一页。==
- **写后分离**：当子进程需要写入时，复制页面并分配新的物理页帧。

------

#### 8.2.2 `fork()`函数

==`fork()`是POSIX定义的最基本的进程创建函数，通过调用`_do_fork()`系统调用实现。父进程在调用`fork()`后，创建一个子进程。子进程拥有与父进程相似的环境，但使用不同的PID。==

```
pid_t fork(void); // 定义在 C 库中
```

- **返回值**：`fork()`会返回两次。对于父进程，返回子进程的PID；对于子进程，返回0。
- 差异：
  - 子进程和父进程有独立的ID。
  - 子进程不会继承父进程的内存锁、信号处理等信息。

在Linux内核中，`fork()`实现如下：

```
SYSCALL_DEFINE0(fork) {
    return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);
}
```

------

#### 8.2.3 `vfork()`函数

`vfork()`与`fork()`类似，但在子进程调用`execve()`或`exit()`之前，父进程会一直阻塞等待，以避免复制内存页表的开销。

- **定义**：

  ```
  pid_t vfork(void);
  ```

- **实现**：在内核中，`vfork()`通过`_do_fork()`实现，增加了`CLONE_VFORK`和`CLONE_VM`标志，表示父进程挂起并与子进程共享地址空间。

```
SYSCALL_DEFINE0(vfork) {
    return _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0, 0, NULL, NULL, 0);
}
```

------

#### 8.2.4 `clone()`函数

`clone()`是Linux提供的强大函数，用于创建线程或进程。`clone()`允许选择性地继承父进程的资源，通过多种标志灵活控制创建的线程或进程的属性。

```
int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);
```

- **参数说明**：
  - `fn`：子进程/线程执行的函数。
  - `child_stack`：子进程/线程的栈起始地址。
  - `flags`：标志位，用于设置共享资源。
  - `arg`：传递给子进程/线程的参数。
- **实现**：通过系统调用`_do_fork()`实现。

```
SYSCALL_DEFINE5(clone, unsigned long, clone_flags,
                unsigned long, newsp,
                int __user *, parent_tidptr,
                int __user *, child_tidptr,
                unsigned long, tls) {
    return _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);
}
```

- 常用标志位：

  - `CLONE_VM`：共享地址空间。
  - `CLONE_FS`：共享文件系统信息。
  - `CLONE_FILES`：共享打开的文件。
  - `CLONE_SIGHAND`：共享信号处理。
  - `CLONE_THREAD`：在同一个线程组中。

------

#### 8.2.5 内核线程

==内核线程是运行在内核空间中的特殊进程，与用户进程不同，它没有独立的地址空间。内核线程用于完成系统任务，如`kswapd`等。==

```
// 创建内核线程的接口
kthread_create(threadfn, data, namefmt, arg...);
kthread_run(threadfn, data, namefmt, ...);
```

------

#### 8.2.6 `_do_fork()`函数

==`_do_fork()`是`fork()`、`vfork()`和`clone()`的核心实现函数。它创建子进程的`task_struct`，并复制父进程的必要信息到子进程。==

```
long _do_fork(unsigned long clone_flags, unsigned long stack_start,
              unsigned long stack_size, int __user *parent_tidptr,
              int __user *child_tidptr, unsigned long tls) {
    // 通过 copy_process 函数创建子进程的 task_struct
}
```

- 参数说明：
  - `clone_flags`：标志位。
  - `stack_start`：栈起始地址。
  - `parent_tidptr`：父进程ID指针。
  - `child_tidptr`：子进程ID指针。
  - `tls`：传递的TLS参数。

------

#### 8.2.7 终止进程

==进程的终止分为主动和被动两种方式。==

- **主动终止**：
  - ==`main()`函数返回时调用`exit()`。==
  - ==主动调用`exit()`系统调用。==
- **被动终止**：
  - 接收到无法处理的信号。
  - 内核态产生异常。
  - 接收`SIGKILL`等信号。

当进程终止时，Linux内核会释放资源并通知父进程。`exit()`系统调用会将退出码转换成特定格式，并调用`do_exit()`来完成进程的终止操作。

------

#### 8.2.8 僵尸进程和托孤进程

- **僵尸进程**：==当进程通过`exit()`终止后，会进入僵尸状态，保留`task_struct`以记录终止原因。父进程通过`wait()`系统调用获取信息后，内核才会释放`task_struct`。==

  ```
  asmlinkage long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);
  ```

- **托孤进程**：==如果父进程先于子进程终止，子进程会成为孤儿进程并交由`init`进程接管。==

------

#### 8.2.9 进程0和进程1

- **进程0**：Linux内核在初始化阶段创建的内核线程，作为所有进程的祖先，别名包括`idle`进程、`swapper`进程。进程0的描述符在`init_task.c`中静态初始化。

  ```
  struct task_struct init_task = {
      .state = 0,
      .stack = init_stack,
      .active_mm = &init_mm,
  };
  ```

- **进程1**：内核启动后创建的第一个用户进程，负责初始化系统配置和启动用户登录界面。`init`进程从内核线程转为普通进程，通过`execve()`加载`/sbin/init`或`/bin/sh`，在SMP系统中，每个CPU都有一个独立的`idle`进程。

------

以上是8.2节关于进程创建和终止的详细总结与实现细节的完整说明。