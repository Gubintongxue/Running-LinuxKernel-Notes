# 第8章 进程管理

## 8.1 进程

8.1.1进程的由来

进程可以理解为**执行中的程序**，即程序加载到内存并执行后就成为一个进程。

CPU在同一时间只能执行一个任务，但是通过快速的进程切换，让用户产生伪并行的错觉。



8.1.2进程描述符

在Linux内核中，使用`task_struct`数据结构来描述进程信息，该结构体被称为进程控制块(PCB)。

包含进程所需的所有信息，用于系统管理进程的生命周期和状态。

结构划分：

- 进程状态信息。
- CPU寄存器和程序计数器。
- 进程的优先级、调度信息。
- 进程的内存管理和文件管理信息。
- 信号处理和资源限制。

`task_struct` 关键成员解析

- `state`：进程状态，使用多个宏定义表示不同状态，如`TASK_RUNNING`表示可运行状态。
- `pid`：进程标识符，唯一标识每个进程。
- `flags`：进程的特殊属性标志位。
- `exit_code`和`exit_signal`：用于父进程得知子进程的退出状态。
- `comm`：存储可执行文件名称，用于标识进程。



8.1.3 进程的生命周期

进程的生命周期包含五种状态：

1. **创建态**：新进程创建。
2. **就绪态**：进程获得所需资源，等待CPU调度。
3. **运行态**：进程占用CPU并执行。
4. **阻塞态**：等待资源时进入阻塞队列。
5. **终止态**：进程完成执行或被终止，进入僵尸状态。



8.1.4 进程标识

- **PID**：每个进程都有一个唯一的进程标识符(PID)，用于区分进程。
- **TGID**：线程组ID，指示同一线程组的多个线程共享相同的TGID。

系统调用：getpid(),gettid()



8.1.5 进程间的家族关系

- **进程层级**：系统最初的进程为`init_task`（进程0），由其衍生出所有用户进程。
- **关系**：父子关系、兄弟关系、祖孙关系。





8.16 获取当前进程

**`current`宏**：用于快速获取当前正在运行的进程的`task_struct`指针。

**说明**：`current`宏利用CPU寄存器指向当前进程的`task_struct`。



## 8.2 进程的创建和终止

POSIX标准定义了一些用于进程创建和终止的系统原语，包括`fork()`、`execve()`、`wait()`、`waitpid()`、`kill()`以及`exit()`等函数。Linux在实现中进行了扩展，引入了`vfork()`和`clone()`，以提高进程创建的效率。



8.2.1 写时复制技术

在使用COW技术时，父子进程共享相同的物理内存。当进程尝试修改内存时，触发缺页异常，再将该内存页复制，确保双方拥有各自的副本。



8.2.2 fork()函数

`fork()`是POSIX定义的最基本的进程创建函数，通过调用`_do_fork()`系统调用实现。父进程在调用`fork()`后，创建一个子进程。子进程拥有与父进程相似的环境，但使用不同的PID。



现版本linux内核中不使用do_fork，而使用kernel_clone和copy_process，见疑问。



8.2.3 vfork()函数

`vfork()`与`fork()`类似，但在子进程调用`execve()`或`exit()`之前，父进程会一直阻塞等待，以避免复制内存页表的开销。

**实现**：在内核中，`vfork()`通过`_do_fork()`实现，增加了`CLONE_VFORK`和`CLONE_VM`标志，表示父进程挂起并与子进程共享地址空间。



8.2.4 clone()函数

`clone()`是Linux提供的强大函数，用于创建线程或进程。`clone()`允许选择性地继承父进程的资源，通过多种标志灵活控制创建的线程或进程的属性。



8.2.5 内核线程

内核线程是运行在内核空间中的特殊进程，与用户进程不同，它没有独立的地址空间。内核线程用于完成系统任务，如`kswapd`等。

```
// 创建内核线程的接口
kthread_create(threadfn, data, namefmt, arg...);
kthread_run(threadfn, data, namefmt, ...);
```



8.2.6 do_fork()函数

`_do_fork()`是`fork()`、`vfork()`和`clone()`的核心实现函数。它创建子进程的`task_struct`，并复制父进程的必要信息到子进程。

```
long _do_fork(unsigned long clone_flags, unsigned long stack_start,
              unsigned long stack_size, int __user *parent_tidptr,
              int __user *child_tidptr, unsigned long tls) {
    // 通过 copy_process 函数创建子进程的 task_struct
}
```

参数说明：

- `clone_flags`：标志位。
- `stack_start`：栈起始地址。
- `parent_tidptr`：父进程ID指针。
- `child_tidptr`：子进程ID指针。
- `tls`：传递的TLS参数。



8.2.7 终止进程

进程的终止分为主动和被动两种方式。

- **主动终止**：
  - `main()`函数返回时调用`exit()`。
  - 主动调用`exit()`系统调用。
- **被动终止**：
  - 接收到无法处理的信号。
  - 内核态产生异常。
  - 接收`SIGKILL`等信号。



8.2.8 僵尸进程和托孤进程

**僵尸进程**：当进程通过`exit()`终止后，会进入僵尸状态，保留`task_struct`以记录终止原因。父进程通过`wait()`系统调用获取信息后，内核才会释放`task_struct`。

**托孤进程**：如果父进程先于子进程终止，子进程会成为孤儿进程并交由`init`进程接管。



8.2.9 进程0和进程1

**进程0**：Linux内核在初始化阶段创建的内核线程，作为所有进程的祖先，别名包括`idle`进程、`swapper`进程。进程0的描述符在`init_task.c`中静态初始化。

**进程1**：内核启动后创建的第一个用户进程，负责初始化系统配置和启动用户登录界面。`init`进程从内核线程转为普通进程，通过`execve()`加载`/sbin/init`或`/bin/sh`，在SMP系统中，每个CPU都有一个独立的`idle`进程。



## 8.3 进程调度

8.3.1进程的分类

1. **CPU消耗型（CPU-Bound）**：进程大部分时间在执行计算，持续占用CPU资源。例如大量数学计算、循环操作。
2. **I/O消耗型（I/O-Bound）**：进程大部分时间在等待I/O操作，仅偶尔需要CPU时间，例如等待键盘输入或网络I/O的进程。

8.3.2 进程的优先级和权重

##### 优先级字段示例（task_struct数据结构）

```
struct task_struct {
    int prio;           // 动态优先级，用于调度
    int static_prio;    // 静态优先级，初始分配，用户可调
    int normal_prio;    // 基于static_prio计算出的优先级
    unsigned int rt_priority; // 实时进程优先级
};
```



8.3.3 调度策略

调度策略决定了进程何时获得CPU以及运行时长。Linux内核将不同的调度策略归纳为五个调度类，每类由`sched_class`定义，并以`next`指针串联。

##### Linux调度类

1. **stop类**：优先级最高，负责进程迁移、系统负载均衡等特殊任务。
2. **deadline类**：严格的实时调度类，适用于高实时性要求的任务，如视频编解码。
3. **realtime类**：包括`SCHED_FIFO`和`SCHED_RR`，适用于IRQ线程化等实时任务。
4. **CFS类**：完全公平调度类，管理普通进程。
5. **idle类**：最低优先级，用于系统空闲时运行。



8.3.4 时间片

时间片定义了进程可连续运行的时间，长度决定了系统的响应速度和调度效率。传统Linux调度器使用固定时间片，现代完全公平调度器（CFS）根据进程权重动态分配时间片。

- **时间片的平衡**：I/O密集型进程需要较短的时间片以响应I/O操作；CPU密集型进程希望获得较长的时间片以降低切换开销。
- **CFS的动态时间片**：==CFS根据进程的权重和系统总权重来分配CPU时间，优先级高的进程权重较大，获得更多CPU时间。==



8.3.5 经典调度算法

多级反馈队列算法MLFQ

##### 基本规则

1. **规则1**：如果进程A的优先级高于进程B，调度器优先选择进程A。
2. **规则2**：如果进程A和B的优先级相同，采用轮转调度算法。
3. **规则3**：新进程进入时，放入优先级最高的队列。
4. **规则4a**：当进程在时间片用尽后，将其优先级降低，移动到下一级队列。
5. **规则4b**：如果进程在时间片未结束时放弃CPU，保持其优先级不变，留在当前队列。

##### 改进规则

- **规则5**：为防止低优先级进程的“饥饿”现象，每隔一个时间周期S，将所有进程的优先级提升至最高。通过调整S的大小，可以控制系统交互性和响应时间。
- **新的规则4**：防止进程欺骗调度器，所有使用完时间片的进程，无论是否在时间片末尾发起I/O请求，都会被降低优先级。



8.3.6 Linux O(n)调度算法



8.3.7 Linux O(1)调度算法



==8.3.8 Linux CFS算法==

完全公平调度器（CFS）引入了权重和虚拟时间(`vruntime`)的概念，抛弃了固定时间片和固定调度周期。

**权重和虚拟时间**：每个进程的虚拟时间`vruntime`由实际运行时间和权重的比值计算得到。优先级高的进程权重大，虚拟时间增速慢，从而获得较多CPU时间；优先级低的进程权重小，虚拟时间增速快，获得的CPU时间较少。

- **权重表**：Linux内核预先计算了一张权重表`sched_prio_to_weight`，nice值为0的权重为1024。nice值越低，权重越大，进程获得更多的CPU时间。

**虚拟时间计算**：CFS的关键是`vruntime`的计算，每个调度实体的数据结构`load_weight`包含权重和逆权重信息。





==8.3.9 进程切换==

在Linux内核中，`_schedule()`是调度器的核心函数，用于选择和切换到合适的进程执行。进程切换时机包括阻塞操作、检查调度标志位`TIF_NEED_RESCHED`等情况。





==8.3.10 与调度相关的数据结构==

与调度器操作密切相关的几个重要数据结构，如 `task_struct`、`sched_entity`、`rq`、`cfs_rq` 以及调度类的操作方法等。





## 8.4 多核调度

随着多核处理器的普及，Linux 内核逐渐优化了其调度机制，以支持对称多处理（SMP）系统。在这种系统中，各核心对等，共享内存和系统总线。调度器的多核优化设计不仅考虑单核性能，还要尽量平衡多核系统的负载。



8.4.1 调度域和调度组

多核架构分为若干个物理域，Linux 内核通过 `sched_domain_topology_level` 数据结构来描述 CPU 的层次关系。常见的 CPU 层次结构包括：

1. **SMT（Simultaneous MultiThreading）**：一个物理核心具有多个逻辑线程，共享 L1 缓存，适用于超线程技术。
2. **MC（Multi-Core）**：多核结构，每个物理核心独享 L1 缓存，而一个集群共享 L2 缓存。
3. **DIE（处理器 SoC 层级）**：表示整个 SoC 处理器。

#### 调度域与调度组

- **调度域（sched_domain）**：用于描述不同层级的调度范围和策略。
- **调度组（sched_group）**：在最低层级中，通常用于描述每个 CPU 核心，是负载均衡的最小单元。



8.4.2 负载的计算

在多核处理器的环境下，计算 CPU 的负载不仅仅是简单的就绪队列中进程数量的总和。需要考虑到进程的 CPU 使用模式和历史负载，以更准确地反映每个 CPU 上的实际负载情况。负载计算的改进经过了从直接的权重求和到引入量化负载的过程。

基础负载计算

引入时间因素的负载计算

PELT（Per-Entity Load Tracking）



8.4.3 负载均衡算法

在 SMP 系统中，负载均衡通过软中断触发的调度 tick 中断来检查是否需要负载均衡。`rebalance_domains()` 函数是负载均衡的入口。负载均衡流程为：

1. 从当前 CPU 开始遍历调度域，由下至上进行负载均衡。
2. 若当前 CPU 是调度域的第一个 CPU 或者是空闲 CPU，允许负载均衡。
3. 查找调度域中最繁忙的调度组，更新调度域和调度组信息。
4. 在最繁忙的 CPU 中找到适合迁移的进程，将其迁移到当前 CPU。



8.4.4 Per-CPU 变量

为了提升性能和减少 CPU 间竞争，Linux 内核引入了 Per-CPU 变量，每个 CPU 都拥有该变量的独立副本，从而避免了锁竞争和缓存一致性问题。