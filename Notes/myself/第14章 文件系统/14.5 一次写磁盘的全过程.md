### 14.5 一次写磁盘的全过程

在 Linux 内核中，当执行写操作时（例如将数据写入文件 `mytest.c`），该操作会经历一系列步骤，从用户空间陷入内核，直到最终将数据写入磁盘。以下是写操作的 C 代码示例：

```
int fd = open("mytest.c", O_RDWR);
ret = write(fd, buffer, 4096);
```

在这段代码中，我们希望将 `buffer` 中的数据写入文件 `mytest.c`。下面是 `write()` 函数在内核态的执行过程（如图 14.13 所示），假设不使用日志写入。

#### 14.5.1 写操作过程详解

1. **系统调用**：==用户空间调用 `write()` 函数，通过系统调用陷入内核空间，进入 `sys_write()` 函数。==
2. **VFS 层处理**：==进入虚拟文件系统（VFS）层，通过文件描述符 `fd` 找到对应的 `file` 结构体，该结构体包含文件的元数据和文件操作方法。==
3. **页面缓存查找**：==在文件的页面缓存基数树中查找对应的页面。==页面缓存是内存中用于缓存文件内容的区域。如果没有找到该页面，系统会为该文件创建相应的页面缓存，并将其添加到页面缓存基数树中。
4. **分配 Buffer Head 队列**：根据磁盘块大小，分配 `buffer_head`（BH）队列，BH 是指向页面缓存页面的结构，作为数据和磁盘块之间的桥梁。
5. **分配磁盘块**：==通过文件系统的 `get_block()` 接口分配磁盘块号，为用户数据在磁盘上找到合适的物理块位置。==
6. **数据复制**：==将用户空间的数据复制到页面缓存中的页面里。==
7. **标记脏页**：==标记页面缓存和 `buffer_head` 为脏页，将文件的 `inode` 添加到标记为脏的链表中。标记脏页意味着该页需要回写到磁盘，以保持文件系统的一致性。==
8. **回写线程启动**：==内核中的回写线程负责将脏数据回写到磁盘。==回写线程会遍历脏页链表，从中取出标记为脏的页面缓存，为其创建一个 BIO（Block I/O）对象。BIO 包含所有必要的请求信息，提交到通用块层的 I/O 请求队列中。
9. **磁盘驱动获取 I/O 请求**：磁盘驱动从通用块层提取 I/O 请求。
10. **DMA 写入**：磁盘驱动发起 DMA 操作，通过 DMA（Direct Memory Access）方式将 `buffer_head` 中的数据写入磁盘。

#### 14.5.2 关键数据结构与模块

- **页面缓存**：用于缓存文件内容的页面集合，减小对磁盘的直接读写，提升系统性能。
- **buffer_head**：链接页面缓存与磁盘块的结构，管理数据从页面缓存到磁盘块的流转。
- **BIO（Block I/O）对象**：表示从文件系统发起的 I/O 请求，包含一次请求的所有信息。
- **通用块层**：协调各个文件系统的 I/O 请求，将请求排队并管理与磁盘驱动的交互。
- **回写线程**：内核中的守护线程，定期扫描脏页并将它们写回磁盘，保持缓存与磁盘内容的一致性。

通过这一流程，Linux 实现了用户空间到内核空间、文件系统到块设备层的写操作完整链路，确保数据顺利写入磁盘，并通过页面缓存和 `buffer_head` 的管理，优化了性能和资源利用效率。