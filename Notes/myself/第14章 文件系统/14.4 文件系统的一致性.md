### 14.4 文件系统的一致性

==文件系统在发生断电或系统崩溃时，需要保证数据的一致性和完整性。为此，文件系统需要确保在写操作被中断时，不会留下损坏的数据或错误的元数据。==下面通过一个简单的示例以及日志文件系统的机制来说明如何实现数据一致性。

#### 14.4.1 文件系统不一致性示例

==假设有一个大小为 4KB 的文件 `mytest.c`，我们希望在该文件的末尾追加 4KB 数据。==这个操作会涉及以下步骤：

1. 分配一个新的数据块（假设是 `Data2`）。
2. 更新块位图，将 `Data2` 标记为已分配。
3. 更新文件的 inode，新增一个直接指针指向 `Data2` 数据块。
4. 将新数据写入 `Data2`。

这些步骤需要更新三个块：inode 表、块位图以及 `Data2` 数据块。假如在这些步骤未完全完成时系统崩溃，将导致以下不一致性问题：

- **系统崩溃发生在更新块位图之后**：==块位图已标记 `Data2` 为已分配，但 inode 尚未指向它，导致 `Data2` 数据块被空闲但未使用。==
- **系统崩溃发生在更新 inode 后**：==此时 `Data2` 数据块虽然被 inode 引用，但其中的数据未写入或是无效数据，对用户而言文件内容将被破坏。==

#### 14.4.2 日志文件系统的解决方案

==为了解决上述问题，文件系统引入了日志文件系统机制，通过日志记录来保证写入操作的原子性。日志文件系统的基本原理是将写入操作作为一个事务（transaction），并在正式写入数据之前，将事务的各个步骤写入日志区。常见的日志文件系统包括 ext4、xfs 等。==

==日志文件系统的写入过程分为以下四个阶段：==

1. **写日志**：将操作的步骤记录到日志区，包括分配空闲块、更新块位图、更新 inode 等操作。
2. **提交日志**：标记事务完成，将日志标记为已提交（committed）。
3. **添加检查点**：将日志中的实际内容写入磁盘，更新 inode 表、块位图和数据块。
4. **释放日志**：将日志标记为空闲，便于后续事务使用。

==如果系统崩溃发生在提交日志之前，日志会被认为无效，文件系统将跳过这些未完成的日志，保证文件系统的一致性。而如果崩溃发生在提交日志之后但在添加检查点之前，系统可以在重启时扫描日志，完成未完成的事务，从而恢复数据一致性。==

#### 14.4.3 日志模式

==日志文件系统提供了不同的日志模式，以平衡一致性和性能：==

1. **数据日志模式（Data Journaling）**：==将元数据和普通数据都记录到日志中。虽然可以提供最严格的数据保护，但会增加磁盘 I/O 负担，影响性能。==
2. **元数据日志模式（Metadata Journaling）**：==仅记录元数据的变化，不记录数据本身。这种模式会先写入数据，再写入元数据日志。元数据日志模式分为以下两种：==
   - **元数据日志（Metadata Journaling）**：只记录元数据，降低了日志开销，但需要确保数据在写入元数据日志前已经同步到磁盘。
   - **有序日志（Ordered Journaling）**：在写日志之前，先确保数据块被写入磁盘，再写入元数据日志。这种方式保证元数据和数据的一致性，但开销较小。

### 总结

日志文件系统通过分阶段写日志的机制保障了文件系统在崩溃或异常情况下的数据一致性。不同的日志模式（数据日志和元数据日志）提供了从最严格保护到性能优化的不同方案。元数据日志模式下，仅记录元数据的变更可以有效地降低 I/O 开销，平衡了性能和一致性需求，成为主流文件系统的一种重要机制。

------

