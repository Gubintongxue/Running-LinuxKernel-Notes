# 第14章 文件系统

## 14.1 文件系统的基本概念

14.1.1 文件

文件是文件系统的基本存储单位，用户可以通过文件方便地在磁盘上保存和读取信息。

文件的命名

文件类型：普通、目录、特殊：用于表示设备文件、系统节点（如 `procfs`、`sysfs`）等。

文件属性：文件属性（或元数据）包括文件大小、权限、创建日期、修改日期等。

文件操作：文件操作是文件系统的核心，常见操作包括创建、打开、读取、写入、关闭、重命名和删除等



14.1.2 目录

目录用于管理文件系统的层次结构，存储文件的路径信息。目录包含目录项（如文件名及其位置等）以便操作系统能够快速定位文件。很多操作系统将目录本身视为一种文件，并支持层次化的目录结构（通常以树形结构展现），这种树形结构从根目录（通常标识为`/`）开始，逐层分布目录和文件。

在树状结构目录系统中，有两种路径方式来指定文件或目录的位置：绝对路径和相对路径

目录操作





## 14.2 文件系统的基本概念和知识

14.2.1 文件系统的布局

文件系统通常安装在磁盘分区上。一个磁盘可以被分成多个分区，每个分区可以包含不同类型的文件系统（如 `ext2`、`ext4` 等）。一个标准磁盘的基本布局包括：

- **MBR（主引导记录）**：位于第0号扇区，包含启动程序，用于引导系统。
- **分区表**：记录磁盘分区的起始和结束位置。
- **分区**：包含文件系统，用于实际的数据存储。

#### 文件系统分区布局

在文件系统分区中，操作系统将磁盘的最小操作单位视为块（block），而文件系统需要有效地管理这些块。在 `ext2` 文件系统中，典型布局包括以下几个部分：

1. **超级块（superblock）**：记录文件系统的总体信息，如块数量、inode数量、空闲块数量等，是文件系统的核心元数据。
2. **组描述符（Group Descriptor）**：用于描述每个块组的信息，如块位图位置、inode位图位置、inode表的起始位置等。
3. **块位图和 inode 位图**：分别记录哪些数据块和哪些 inode 已被分配或仍为空闲。
4. **inode 表**：保存文件和目录的 inode，记录每个文件或目录的元数据信息。
5. **数据块区域**：存储文件和目录的数据内容。



14.2.2 索引数据块

在文件系统中，关键任务之一是有效分配和索引数据块的位置。`ext2` 文件系统使用直接指针和多级间接指针来管理数据块索引，以支持不同大小的文件：

- **直接指针**：`ext2` 的 `inode` 中包含 12 个直接指针，每个直接指针指向一个数据块，适用于小文件。这 12 个直接指针可以索引总共 `12 × 4KB = 48KB` 的文件数据。

- **一级间接指针**：当文件超出直接指针的容量，`ext2` 采用一级间接指针，即 `inode` 的某个指针指向一个包含 1024 个指针的块，每个指针指向一个数据块，支持更大的文件。

- 二级和三级间接指针：如果一级间接指针仍无法支持文件大小，ext2还提供二级和三级间接指针，分别通过指针的多级跳转来支持极大的文件存储空间。每增加一层指针级别，支持的文件大小会显著增加。例如：

  - 一级间接索引支持约 `4 MB` 文件。
  - 二级间接索引支持约 `4 GB` 文件。
  - 三级间接索引进一步扩展文件大小限制。



14.2.3 管理空闲块

管理磁盘中的空闲块是文件系统的重要功能。`ext2` 使用位图记录空闲和已使用的块状态。当分配一个新文件时，文件系统会先分配一个 `inode`，然后通过块位图查找空闲块，并为该 `inode` 分配存储空间。`ext2` 提供 `ext2_get_block()` 函数来分配空闲块并建立映射关系。

现代文件系统如 `ext4` 使用 B 树来组织空闲块信息，进一步提高了查找效率，尤其是在大文件系统中。

14.2.4 高速缓存

文件系统通常会缓存文件和目录的信息以减少磁盘 I/O，提高性能。Linux 系统采用页面缓存（page cache）和缓冲区缓存（buffer cache）。





## 14.3 虚拟文件系统层

虚拟文件系统（VFS）为不同的文件系统提供统一的接口和抽象层，使得用户和应用程序能够通过标准系统调用（如 `open()`、`read()`、`write()` 等）与底层文件系统交互，而无需关心具体的文件系统类型（如 `ext4`、`xfs`、`FAT32` 等）。VFS 在 Linux 内核中实现了面向对象的思想，主要包含四类对象：文件对象、超级块对象、inode 对象和目录项对象。

14.3.1. 文件对象

文件对象表示打开的文件实例，由系统调用 `open()` 创建，并由 `close()` 释放。文件对象在内核中以 `struct file` 数据结构表示，包含了文件路径、文件描述符、文件的操作方法集等信息。



14.3.2. 超级块对象

超级块对象代表了挂载的文件系统实例，使用 `struct super_block` 描述。超级块包含文件系统的元数据信息，如块大小、文件系统类型、最大文件大小等。



==14.3.3. inode 对象==

==inode 是文件的核心数据结构，包含文件的元数据（如大小、权限、时间戳等）以及指向数据块的指针。每个文件和目录都对应一个 inode，使用 `struct inode` 数据结构表示。==

- **主要成员**：
  - `i_mode`：文件的访问权限。
  - `i_uid` 和 `i_gid`：文件所有者的用户 ID 和组 ID。
  - `i_size`：文件大小。
  - `i_blocks`：文件占用的块数。
  - `i_op`：inode 的操作方法集。
  - `i_mapping`：文件的数据映射，指向文件的页缓存。
  - `i_atime`、`i_mtime`、`i_ctime`：文件的访问时间、修改时间和状态改变时间。
- **常见方法集（`struct inode_operations`）**：
  - `lookup`：在目录中查找 inode。
  - `create` 和 `mkdir`：创建文件和目录。
  - `unlink` 和 `rmdir`：删除文件和目录。
  - `symlink` 和 `link`：创建符号链接和硬链接。
  - `rename`：重命名文件或目录。



14.3.4. 目录项对象

目录项对象（dentry）表示文件系统中的路径组件，如文件或目录的名称和层次结构，目录项包含目录树的层次结构信息，便于路径查找。每个目录项由 `struct dentry` 数据结构表示，并使用散列表（哈希表）管理目录项缓存。



### VFS 的工作原理

VFS 通过通用接口和数据结构，将不同的文件系统抽象成统一的模型。用户对文件的操作（如打开、读写、关闭）经过系统调用层处理后，会交由 VFS 进行操作。VFS 层通过 `file_operations`、`super_operations`、`inode_operations` 和 `dentry_operations` 等方法集，结合各个文件系统的具体实现来完成用户请求，实现文件系统的多态支持。



## 14.4 文件系统的一致性

文件系统在发生断电或系统崩溃时，需要保证数据的一致性和完整性。为此，文件系统需要确保在写操作被中断时，不会留下损坏的数据或错误的元数据。

14.4.1 文件系统不一致性示例

假设有一个大小为 4KB 的文件 `mytest.c`，我们希望在该文件的末尾追加 4KB 数据。这个操作会涉及以下步骤：

1. 分配一个新的数据块（假设是 `Data2`）。
2. 更新块位图，将 `Data2` 标记为已分配。
3. 更新文件的 inode，新增一个直接指针指向 `Data2` 数据块。
4. 将新数据写入 `Data2`。

这些步骤需要更新三个块：inode 表、块位图以及 `Data2` 数据块。假如在这些步骤未完全完成时系统崩溃，将导致以下不一致性问题：

- **系统崩溃发生在更新块位图之后**：块位图已标记 `Data2` 为已分配，但 inode 尚未指向它，导致 `Data2` 数据块被空闲但未使用。
- **系统崩溃发生在更新 inode 后**：此时 `Data2` 数据块虽然被 inode 引用，但其中的数据未写入或是无效数据，对用户而言文件内容将被破坏。



14.4.2 日志文件系统的解决方案

为了解决上述问题，文件系统引入了日志文件系统机制，通过日志记录来保证写入操作的原子性。日志文件系统的基本原理是将写入操作作为一个事务（transaction），并在正式写入数据之前，将事务的各个步骤写入日志区。常见的日志文件系统包括 ext4、xfs 等。

日志文件系统的写入过程分为以下四个阶段：

1. **写日志**：将操作的步骤记录到日志区，包括分配空闲块、更新块位图、更新 inode 等操作。
2. **提交日志**：标记事务完成，将日志标记为已提交（committed）。
3. **添加检查点**：将日志中的实际内容写入磁盘，更新 inode 表、块位图和数据块。
4. **释放日志**：将日志标记为空闲，便于后续事务使用。

如果系统崩溃发生在提交日志之前，日志会被认为无效，文件系统将跳过这些未完成的日志，保证文件系统的一致性。而如果崩溃发生在提交日志之后但在添加检查点之前，系统可以在重启时扫描日志，完成未完成的事务，从而恢复数据一致性。



14.4.3 日志模式

日志文件系统提供了不同的日志模式，以平衡一致性和性能：

1. **数据日志模式（Data Journaling）**：将元数据和普通数据都记录到日志中。虽然可以提供最严格的数据保护，但会增加磁盘 I/O 负担，影响性能。
2. **元数据日志模式（Metadata Journaling）**：仅记录元数据的变化，不记录数据本身。这种模式会先写入数据，再写入元数据日志。元数据日志模式分为以下两种：
   - **元数据日志（Metadata Journaling）**：只记录元数据，降低了日志开销，但需要确保数据在写入元数据日志前已经同步到磁盘。
   - **有序日志（Ordered Journaling）**：在写日志之前，先确保数据块被写入磁盘，再写入元数据日志。这种方式保证元数据和数据的一致性，但开销较小。



## 14.5 一次写磁盘的全过程

在 Linux 内核中，当执行写操作时（例如将数据写入文件 `mytest.c`），该操作会经历一系列步骤，从用户空间陷入内核，直到最终将数据写入磁盘。以下是写操作的 C 代码示例：

```
int fd = open("mytest.c", O_RDWR);
ret = write(fd, buffer, 4096);
```

在这段代码中，我们希望将 `buffer` 中的数据写入文件 `mytest.c`。下面是 `write()` 函数在内核态的执行过程（如图 14.13 所示），==假设不使用日志写入。==

#### 14.5.1 写操作过程详解

1. **系统调用**：==用户空间调用 `write()` 函数，通过系统调用陷入内核空间，进入 `sys_write()` 函数。==
2. **VFS 层处理**：==进入虚拟文件系统（VFS）层，通过文件描述符 `fd` 找到对应的 `file` 结构体，该结构体包含文件的元数据和文件操作方法。==
3. **页面缓存查找**：==在文件的页面缓存基数树中查找对应的页面。==页面缓存是内存中用于缓存文件内容的区域。如果没有找到该页面，系统会为该文件创建相应的页面缓存，并将其添加到页面缓存基数树中。
4. **分配 Buffer Head 队列**：根据磁盘块大小，分配 `buffer_head`（BH）队列，BH 是指向页面缓存页面的结构，作为数据和磁盘块之间的桥梁。
5. **分配磁盘块**：==通过文件系统的 `get_block()` 接口分配磁盘块号，为用户数据在磁盘上找到合适的物理块位置。==
6. **数据复制**：==将用户空间的数据复制到页面缓存中的页面里。==
7. **标记脏页**：==标记页面缓存和 `buffer_head` 为脏页，将文件的 `inode` 添加到标记为脏的链表中。标记脏页意味着该页需要回写到磁盘，以保持文件系统的一致性。==
8. **回写线程启动**：==内核中的回写线程负责将脏数据回写到磁盘。==回写线程会遍历脏页链表，从中取出标记为脏的页面缓存，为其创建一个 BIO（Block I/O）对象。BIO 包含所有必要的请求信息，提交到通用块层的 I/O 请求队列中。
9. **磁盘驱动获取 I/O 请求**：磁盘驱动从通用块层提取 I/O 请求。
10. **DMA 写入**：磁盘驱动发起 DMA 操作，通过 DMA（Direct Memory Access）方式将 `buffer_head` 中的数据写入磁盘。

#### 14.5.2 关键数据结构与模块

- **页面缓存**：用于缓存文件内容的页面集合，减小对磁盘的直接读写，提升系统性能。
- **buffer_head**：链接页面缓存与磁盘块的结构，管理数据从页面缓存到磁盘块的流转。
- **BIO（Block I/O）对象**：表示从文件系统发起的 I/O 请求，包含一次请求的所有信息。
- **通用块层**：协调各个文件系统的 I/O 请求，将请求排队并管理与磁盘驱动的交互。
- **回写线程**：内核中的守护线程，定期扫描脏页并将它们写回磁盘，保持缓存与磁盘内容的一致性。