## **9.3 物理内存管理**

本节详细描述了物理内存管理的各个方面，包括物理页面的结构、内存管理区、页面分配与释放机制，以及如何减少内存碎片化问题。它展示了如何在复杂的环境中高效管理物理内存，并详细介绍了Linux内核中的关键机制如伙伴系统和`slab`分配器。

------

### **9.3.1 物理页面**

- **页面的基本概念**：

  - 现代处理器使用分页机制，MMU负责将虚拟地址转换为物理地址。
  - **`struct page`**是描述物理页面的核心结构，定义在`include/linux/mm_types.h`。
  - 每个页面的大小通常为4KB，但也可能支持8KB、16KB等。
- **`struct page`结构解析**（如图9.13所示）：

  1. **flags**：页面标志位，用于描述页面状态。
  2. 引用计数：
  
     - `_refcount`：页面被内核使用的次数。
  - `_mapcount`：页面被映射到多少个进程的页表中。
  3. **mapping**：指向页面所属的文件或匿名内存区域。
  4. **LRU链表**：用于页面回收算法。
  5. **virtual字段**：指向页面的虚拟地址，仅在必要时映射高端内存。

### 原文：

![image-20241021142601241](image/image-20241021142601241.png)

![image-20241021142609644](image/image-20241021142609644.png)

![image-20241021142623275](image/image-20241021142623275.png)

![image-20241021151245225](image/image-20241021151245225.png)

![image-20241021151307557](image/image-20241021151307557.png)

![image-20241021151619504](image/image-20241021151619504.png)

![image-20241021151627802](image/image-20241021151627802.png)

------

### **9.3.2 内存管理区**

- **内存管理区的分类**：

  - **ZONE_DMA**：用于DMA设备的内存。
  - **ZONE_NORMAL**：线性映射的内存区域。
  - **ZONE_HIGHMEM**：高端内存，不直接映射到内核地址空间（仅32位系统使用）。

- **内存管理区的数据结构**：

  - 

    ```
    struct zone
    ```

    用于描述内存管理区，包括以下重要字段：

    - **watermark**：内存区的水位标志（MIN、LOW、HIGH）。
    - **free_area**：管理空闲页面的数组。
    - **lock**：保护内存区的自旋锁。

### 原文：

![image-20241021152326578](image/image-20241021152326578.png)

![image-20241021152335686](image/image-20241021152335686.png)

![image-20241021152347096](image/image-20241021152347096.png)

------

### **9.3.3 分配和释放页面**

- 伙伴系统算法：

  - **原理**：将内存按2的幂次划分，每个内存块都可以与伙伴合并成更大的块（如图9.17）。
  - **`alloc_pages()`**：用于分配连续的物理页面。
  - **`_get_free_pages()`**：返回线性映射的虚拟地址。
  - **`put_page()`**和`get_page()`：管理页面的引用计数，释放或保留页面。



### 原文：

![image-20241021152404207](image/image-20241021152404207.png)

![image-20241021152412002](image/image-20241021152412002.png)

![image-20241021152421068](image/image-20241021152421068.png)

![image-20241021152432072](image/image-20241021152432072.png)

![image-20241021152450921](image/image-20241021152450921.png)

![image-20241021152500705](image/image-20241021152500705.png)



------

### **9.3.4 关于内存碎片化**

- **外部碎片化问题**：
  - 随着时间推移，内存可能无法分配大块连续空间。
  - **解决方案**：采用内存规整（Memory Compaction）和反碎片化技术，将页面迁移以合并空闲区域。
- **反碎片化的迁移类型**：
  - **UNMOVABLE**：不可移动页面，如内核自身使用的页面。
  - **MOVABLE**：可迁移页面，如应用程序分配的匿名页面。
  - **RECLAIMABLE**：可回收页面，如文件缓存页面。

![image-20241021152500705](image/image-20241021152500705.png)

![image-20241021152510912](image/image-20241021152510912.png)

------

### **9.3.5 分配小块内存**

- **slab机制**：

  - **基本概念**：预先分配内存池，加快小块内存的分配与释放。

  - 主要优点：

    - 支持对象级缓存池，减少内存碎片。
- 为每个CPU创建本地对象缓冲池，减少多核竞争。
- **slab的核心数据结构**：

  - **`struct kmem_cache`**：描述缓存池的元数据，包括名称、大小、对齐属性等。
  - **`kmem_cache_create()`**：创建slab描述符。
  - **`kmem_cache_alloc()`**：从缓存池中分配对象。
  - **`kmem_cache_free()`**：释放缓存对象。
- **slab的内存布局**（如图9.22）：

  - 包括**着色区**（cache color）、**对象**和**freelist管理区**。
- **slab机制的运作流程**（如图9.23）：

  1. **创建slab描述符**：每个CPU都有一个本地缓冲池。
  2. **分配内存**：优先从本地缓冲池中获取对象，若无对象则从共享缓冲池获取。
  3. **回收机制**：当空闲对象超过限制时释放内存。
- **kmalloc机制**：

  - **`kmalloc()`**：基于slab机制的分配器，用于分配小块内存（如16、32、64字节）。
  - **`kfree()`**：释放分配的内存块。

### 原文：

将常用的数据结构当成对象来看，内存不紧张时，可以分配若干该对象，类似于内存池。

![image-20241021152603400](image/image-20241021152603400.png)

![image-20241021152624677](image/image-20241021152624677.png)

![image-20241021152643144](image/image-20241021152643144.png)

![image-20241021152652687](image/image-20241021152652687.png)

### 补充：本地CPU概念

**本地 CPU** 是一种上下文相关的说法，常用于**多核系统**中描述任务在某个**具体 CPU 核**上的执行情况。要理解这个概念，我们需要从**多核处理器**、**并发处理**和**缓存管理**等角度来剖析。

#### **1. 什么是“本地 CPU”？**

- 在多核系统（如 ARM 或 x86）中，一个处理器通常包含多个**独立的 CPU 核（Core）**。这些 CPU 核可以同时执行任务。
- **“本地 CPU”**指的是：**当前执行某段代码的 CPU 核**。
- 当你进行某些**线程调度、任务执行或内存分配**时，内核代码会识别并管理在哪个 CPU 核上执行该任务，这个 CPU 核即称为“本地 CPU”。

**例子**：

- 任务 A 正在 CPU 核 0 上运行，我们称 CPU 核 0 是**本地 CPU**。
- 如果任务 B 在 CPU 核 1 上运行，那么对于任务 B 来说，CPU 核 1 是**本地 CPU**。

#### **2. 本地 CPU 的意义**

#### **(1) 性能优化和缓存友好性**

- 每个 CPU 核都有**自己的缓存（L1 缓存）**。如果任务在同一个 CPU 核上反复执行，那么可以减少对共享内存的访问，提升**缓存命中率**，提高性能。这叫**缓存友好性**。

#### **(2) 避免竞争和锁冲突**

- 在多核系统中，为了避免不同 CPU 核对共享资源的争用，操作系统尽量将某个任务固定在**特定 CPU 核**上执行，这样可以减少锁竞争。

#### **(3) 数据局部性**

- 当多个 CPU 核共享同一个内存时，不同的核访问内存会有开销。因此，任务会尽量在同一个 CPU 核上运行，以提高数据的局部性，减少内存开销。

#### **3. 内核中的“本地 CPU”案例**

#### **(1) 内存分配（Per-CPU 缓冲池）**

- 在 Linux 内核中，常用 **Per-CPU 缓冲池（Per-CPU Variables）** 来存储某些数据。这意味着每个 CPU 核有自己的一套数据，这些数据只在**本地 CPU** 上访问，不与其他 CPU 核共享。

  **例子：**

  - Slab 分配器（内核内存管理）会为每个 CPU 核维护一个本地对象缓冲池（local object cache），从而减少多个核之间的锁竞争。

#### **(2) 中断处理**

- 在处理中断时，如果一个 CPU 核正在执行关键任务，系统可能会**将中断转移到其他 CPU 核**处理，以减少对本地 CPU 的打扰。

#### **4. 示例：Per-CPU 变量**

```
// 定义一个 Per-CPU 变量
DEFINE_PER_CPU(int, my_cpu_variable);

// 在本地 CPU 上访问该变量
int local_value = get_cpu_var(my_cpu_variable);
```

在这个代码片段中：

- `my_cpu_variable` 是一个 Per-CPU 变量。
- `get_cpu_var()` 函数会访问**当前本地 CPU 核上的该变量的副本**。

这样做的好处是：

- 每个 CPU 核有自己独立的数据，避免锁争用和共享数据一致性问题。

#### **5. 任务调度中的本地 CPU**

在多核系统的任务调度中，调度器通常会优先选择将任务**调度回之前运行过的 CPU 核**（即本地 CPU），因为这样可以提高**缓存命中率**。这称为 **CPU 亲和性（CPU affinity）**。

#### **6. 本地 CPU 与 NUMA 系统**

在 NUMA（非均匀内存访问）架构中，每个 CPU 核与某一部分物理内存之间有不同的访问延迟。本地 CPU 概念在 NUMA 系统中也很重要，任务应尽量访问**离自己最近的内存**。

#### **总结**

- **本地 CPU**指的是：**当前执行任务或代码的 CPU 核**。
- 在多核系统中，为了提升性能和减少锁竞争，内核会优先将任务固定在同一个 CPU 核上执行，并使用 Per-CPU 缓冲池等机制来减少资源争用。
- **内存分配、任务调度和中断处理**等场景下，“本地 CPU”是一个重要的概念。

------

![image-20241021152703346](image/image-20241021152703346.png)

![image-20241021152712923](image/image-20241021152712923.png)

![image-20241021152721921](image/image-20241021152721921.png)

![image-20241021152729982](image/image-20241021152729982.png)

------

### **总结**

本节深入分析了物理内存的管理方式。通过伙伴系统解决内存的分配与释放问题，并采用`slab`机制提高小块内存的分配效率。同时，Linux内核利用反碎片化和内存规整技术，减轻了内存碎片化带来的影响。通过这些机制，Linux系统能够在复杂环境下高效地管理物理内存资源。