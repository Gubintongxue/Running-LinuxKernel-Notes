### 9.6 内存短缺

Linux 系统在内存有盈余时，内核会尽量使用内存来缓存文件，从而提升系统的整体性能。当系统内存紧张时，内核会进行页面回收，将文件缓存页面丢弃或将被修改的文件缓存页面回写到磁盘，释放内存资源。此外，内核还可以利用交换分区将不常使用的内存页换出至磁盘。这一过程称为页面回收（page reclaim），其中关键机制包括页面回收算法，如 LRU 算法和第二次机会算法。

### 9.6.1 页面回收算法

页面回收算法用于在内存不足时决定哪些页面可以释放。Linux 内核主要使用 LRU 和第二次机会算法。以下是这两种算法的具体实现。

#### 1. LRU（Least Recently Used）算法

==LRU 算法基于“最近最少使用”的原则：假设最近未被使用的页面在短时间内仍然不会被频繁访问，因此在内存不足时优先回收这些页面。==内核将页面分为匿名页面（不关联文件）和文件映射页面（关联具体文件），并为不同类型页面设置不同的 LRU 链表。内核中的 LRU 链表分为以下几种：

- **LRU_INACTIVE_ANON**：不活跃的匿名页面链表。
- **LRU_ACTIVE_ANON**：活跃的匿名页面链表。
- **LRU_INACTIVE_FILE**：不活跃的文件映射页面链表。
- **LRU_ACTIVE_FILE**：活跃的文件映射页面链表。
- **LRU_UNEVICTABLE**：不可回收页面链表。

将 LRU 链表细分为不同的类型是因为在内存不足时，系统通常优先回收文件缓存页面而非匿名页面。对于文件缓存页面来说，如果页面内容没有被修改，则可以直接丢弃；而匿名页面必须写入交换分区才能回收。每个内存管理区（如 ZONE_DMA、ZONE_NORMAL 等）都会维护一组独立的 LRU 链表。

经典 LRU 算法的执行过程如下：

1. **页面加入链表头部**：新分配的页面加入链表的开头。
2. **页面移动至尾部**：在不活跃页面列表中，最早加入的页面逐渐移向链表尾部，等待回收。
3. **页面回收**：当内存紧缺时，链表尾部的页面优先被换出。

#### 2. 第二次机会算法

==经典的 LRU 算法在回收页面时会直接淘汰链表末尾的页面，缺少对页面使用频率的考虑。为避免将频繁使用的页面误淘汰，Linux 内核引入了第二次机会算法。该算法通过设置“访问位”来跟踪页面的访问情况：==

1. **检查访问位**：当页面达到链表尾部时，检查其访问位。如果访问位为 0，则直接淘汰该页面；如果访问位为 1，则给该页面第二次机会，将其移动到链表开头。
2. **清零访问位**：当页面得到第二次机会后，内核清零访问位，防止重复保留。
3. **重复检查**：页面若在获得第二次机会后再度被访问，访问位会再次置为 1，避免被回收。

内核使用 `PG_active` 和 `PG_referenced` 两个标志位来实现第二次机会算法。`PG_active` 表示页面是否活跃，`PG_referenced` 表示页面是否被引用。相关函数包括：

- `mark_page_accessed()`：标记页面为已访问状态。
- `page_referenced()`：检查页面的引用状态。
- `page_check_references()`：验证页面的引用次数，以决定是否给页面第二次机会。

### 页面回收流程

当内存紧张时，内核的页面回收机制依次执行以下步骤：

1. **扫描 LRU 链表**：根据页面的类型和状态，优先回收文件缓存页面或不活跃的页面。
2. **回收页面**：对不活跃页面执行回收操作。如果是文件缓存页面，则直接丢弃未修改的页面；对于匿名页面，内核会将其写入交换分区。
3. **释放页面**：将释放的页面返回内存分配器，供其他进程使用。

### 页交换（Swapping）

当内存紧缺时，内核还可以将不常使用的匿名页面换出至交换分区，以进一步释放物理内存。页交换机制可以通过 `swappiness` 参数调节，数值越大表示系统越倾向于使用交换分区，从而在内存紧张时维持系统的稳定性。

### 9.6.2 OOM Killer 机制

==在 Linux 系统中，当内存耗尽，页面回收和交换机制无法满足内存需求时，最后的措施是启用 **OOM Killer（Out-Of-Memory Killer）**。==OOM Killer 会选择一些内存占用较高的进程终止，以释放内存，确保系统的继续运行。

### OOM Killer 的主要参数

OOM Killer 提供了一些可调节的参数，用于控制不同进程在 OOM 状态下的优先级和是否应被终止。以下是几个关键参数：

1. **`/proc/<pid>/oom_score_adj`**：调整当前进程在 OOM Killer 中的优先级范围，取值范围为 -1000 到 1000。数值越大，进程越容易被选择终止；数值为 -1000 时，表示该进程不会被 OOM Killer 选中终止。
2. **`/proc/<pid>/oom_adj`**：早期版本中用于控制 OOM 选择优先级的参数，取值范围为 -17 到 15。值越大，被选中的可能性越高；值为 -17 时，进程不会被 OOM Killer 选中。当前该参数逐步被 `oom_score_adj` 取代，但为兼容旧版本内核仍暂时保留。
3. **`/proc/<pid>/oom_score`**：表示当前进程的 OOM 分数，基于内存消耗、进程类型等因素计算出。分数越高，表示进程对系统内存压力越大，越可能被 OOM Killer 选中。

### OOM Killer 进程选择算法

OOM Killer 通过以下策略选择进程：

- **高内存占用**：优先选择占用大量内存的进程。
- **低优先级进程**：优先选择对系统影响小的后台进程，而非系统关键进程。
- **可调节性**：通过 `oom_score_adj` 和 `oom_adj` 进一步调整特定进程的优先级，使关键进程如系统服务和守护进程不被 OOM Killer 选中。

### 使用场景与控制建议

OOM Killer 机制是确保系统在极端内存短缺时继续运行的重要保障。为避免不必要的系统服务终止，建议为关键进程设置 `oom_score_adj=-1000`。对于需要释放内存的内存密集型应用，适当提升 `oom_score_adj` 使其更容易被选择，以防止系统崩溃。