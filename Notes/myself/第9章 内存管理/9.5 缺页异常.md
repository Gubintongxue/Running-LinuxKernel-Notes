## 9.5 缺页异常

当进程访问未建立虚拟内存与物理内存映射的虚拟地址时，处理器会触发缺页异常。此异常必须由 Linux 内核处理，涉及匿名页面、文件缓存页面、写时复制、私有和共享映射等多种情况。缺页异常处理依赖于具体的处理器架构，这里以 ARM64 为例进行说明。

#### 缺页异常的处理流程

ARMv8 架构将异常分为同步异常（如缺页异常）和异步异常（如中断）。发生缺页异常时，处理器首先跳转到异常向量表。ARM64 的异常向量表定义在 `arch/arm64/kernel/entry.S` 文件中，通过异常类型跳转到相应的处理函数。

- **ESR寄存器**（Exception Syndrome Register）提供异常类型和指令特定信息。
- **FAR寄存器**（Fault Address Register）存储导致异常的虚拟地址。

以 EL1（内核态）下的数据异常为例，当异常发生后，处理器会读取 ESR 寄存器来判断异常类型，最终跳转到核心处理函数 `do_page_fault()` 进行进一步处理。

### 9.5.1 `do_page_fault()` 函数

==`do_page_fault()` 是处理缺页异常的核心函数，不同架构有相应的实现。==其执行流程如图9.33所示，以下为主要步骤：

1. **VMA查找**：首先通过地址查找 `vm_area_struct`，验证该地址是否在进程的有效虚拟地址范围内。如果地址不在 VMA 中，且异常发生在用户模式下，则会发送 `SIGSEGV` 或 `SIGBUS` 信号以终止进程。
2. **页表项检查**：找到对应页表项后，检查 PTE（Page Table Entry）是否存在。如果 PTE 不存在，且是匿名页面，则调用 `do_anonymous_page()` 分配物理页面并建立映射关系；如果是文件映射页面，则调用 `do_fault()` 从文件加载页面。
3. **写时复制处理**：对于私有映射的页面，在写操作时会触发写时复制，此时调用 `do_wp_page()` 分配一个新的物理页面，并将内容复制到新页面中。
4. **更新页表**：根据页面类型（匿名页面、文件缓存页面等）选择合适的处理函数（如 `do_swap_page()` 处理交换页面，`do_numa_page()` 处理 NUMA 页面），完成页面的分配和映射关系的建立。
5. **刷新 TLB**：更新页表项内容，并刷新相应的 TLB（Translation Lookaside Buffer）和缓存，确保页表变更后地址转换正常。

### 总结

`do_page_fault()` 通过查找和更新页表、调用不同的页面处理函数、根据页面类型动态分配物理页面等步骤来处理缺页异常。缺页异常机制是虚拟内存管理的关键，确保了系统在需要时按需分配物理内存，从而提升内存利用效率。这一机制也为内核提供了灵活的内存管理策略，可以根据页面访问模式、匿名和文件映射需求动态调整内存资源。



### 9.5.2 匿名页面缺页异常

==在 Linux 内核中，没有关联到具体文件的页面称为匿名页面。常见的匿名页面包括通过 `malloc()` 函数分配的内存或使用 `mmap` 创建的匿名映射区域。当进程访问这些尚未映射的匿名页面时，处理器会触发缺页异常，内核调用 `do_anonymous_page()` 函数来处理。==该函数会执行以下步骤：

1. **分配物理页面**：内核通过页面分配器为匿名页面分配物理内存。
2. **初始化页面内容**：新分配的物理页面通常初始化为零，确保没有残留数据。
3. **更新页表**：内核更新相应的页表项，建立虚拟地址与新分配物理页面的映射关系。
4. **刷新 TLB**：为了使映射生效，内核刷新 TLB 以确保地址转换正常。

这种按需分配（Lazy Allocation）策略不仅节约内存资源，还提升了系统性能。

### 9.5.3 文件映射缺页异常

==文件映射指的是将文件内容映射到进程地址空间中，使得进程可以通过访问虚拟地址来直接操作文件内容。文件映射页面的缺页异常与匿名页面不同，通常由 VMA 的 `fault()` 方法来处理。`fault()` 方法在 `vm_operations_struct` 结构体中定义，当文件映射页面不在内存中且被访问时，内核调用此方法处理缺页异常。==`vm_operations_struct` 的结构体如下：

```C
struct vm_operations_struct {
    void (*open)(struct vm_area_struct * area);
    void (*close)(struct vm_area_struct * area);
    int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
    void (*map_pages)(struct vm_area_struct *vma, struct vm_fault *vmf);
    int (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);
    int (*access)(struct vm_area_struct *vma, unsigned long addr,
                  void *buf, int len, int write);
    const char *(*name)(struct vm_area_struct *vma);
    struct page *(*find_special_page)(struct vm_area_struct *vma,
                                       unsigned long addr);
};
```

当 `fault()` 方法被调用时，它将执行以下步骤：

1. **查找或分配页面**：如果页面在页高速缓存中已存在，直接使用；否则，分配一个新页面，并将文件内容读入该页面。
2. **更新页表**：内核更新页表项，将文件内容页面映射到进程的虚拟地址。
3. **同步页面状态**：根据文件的读写属性，设置相应的页面状态（如只读、写时复制等），确保页面属性与文件的权限一致。

通过这种机制，进程可以高效地访问文件内容，而无需显式的文件读写操作。

### 9.5.4 写时复制缺页异常

==写时复制（Copy-On-Write，COW）是一种推迟数据复制的优化技术，主要用于 `fork` 系统调用。当内核为子进程创建地址空间时，它会将父进程的页面映射到子进程，但设置为只读属性。这样，父子进程可以共享同一物理页面，直到其中一方需要写入该页面，才触发 COW 操作。==

在写时复制的缺页异常处理中，`do_wp_page()` 是关键的处理函数，其处理流程如下：

1. **检测写入需求**：`do_wp_page()` 检查页面是否需要写入，确保只读的页面被写入时触发写时复制。
2. **分配新页面**：为需要写入的进程分配一个新的物理页面。
3. **数据复制**：将旧页面内容复制到新页面，保证写入不会影响父子进程的独立数据。
4. **更新页表**：重新设置页表项，将新页面映射到进程的虚拟地址，并修改页面属性为可写。
5. **刷新 TLB**：内核刷新 TLB，确保地址变更立即生效。

写时复制机制极大地节省了内存资源，因为只有在实际写入操作时才分配和复制数据。COW 也适用于 `mmap` 私有映射区域，在需要写入时通过 `do_wp_page()` 动态分配独立页面，使各进程的写入操作互不干扰。