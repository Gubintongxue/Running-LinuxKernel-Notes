## expert总结

### 9.2 从软件角度看内存管理

在 Linux 系统中，从不同的层次和角度看内存管理会产生不同的理解。普通用户通过 `free` 命令可以了解内存的使用情况，应用开发者则通常依赖 `malloc()` 和 `mmap()` 等内存管理函数来分配和释放内存。而从内核角度看，内存管理涉及更复杂的资源分配、虚拟内存、页表管理等机制。以下是详细的解析：

#### 9.2.1 `free` 命令

`free` 命令是 Linux 用户常用的内存查看工具，显示系统的物理内存、交换内存以及缓冲区的使用情况，具体选项包括：

- `-b`、`-k`、`-m`、`-g`：分别以字节、千字节、兆字节和吉字节为单位显示内存情况。
- `-s <间隔秒数>`：每隔指定秒数显示内存使用情况，用于持续观察。
- `-t`：显示总计内存情况。
- `-V`：显示 `free` 的版本信息。

使用 `free -m` 命令的输出示例如下：

```
plaintext复制代码$ free -m
       total        used        free      shared  buff/cache   available
Mem:    7763        5507          0         907        1348        1609
Swap:  16197        2940       13257
```

各字段含义如下：

- **total**：系统中总的内存大小，包括物理内存（Mem）和交换区（Swap）。
- **used**：当前程序使用的内存大小。
- **free**：尚未分配的物理内存大小。
- **shared**：用于进程间通信的共享内存大小。
- **buff/cache**：包括 `buffers`（块设备缓存）和 `page cache`（文件缓存）。
- **available**：可用内存，即系统在内存紧张时能够回收的内存。它并非简单的 `free + buffers + page cache`，因为其中有不可回收的部分，如共享内存段、`tmpfs` 和 `ramfs`。

#### 9.2.2 从应用编程角度看内存管理

在应用开发中，开发者主要使用 `malloc()` 和 `mmap()` 函数分配虚拟内存。其中：

- **`malloc(size_t size)`**：从堆中分配指定大小的虚拟内存，返回内存块的指针。该函数本质上分配虚拟内存，具体的物理内存分配可能推迟到真正使用该内存时。
- **`mmap()`**：通常用于分配较大的内存块，特别是映射文件或匿名内存时，返回一个指定地址或系统分配的地址。

此外，还有一些常用的内存管理函数：

```
void free(void *ptr);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
int getpagesize(void);
int mprotect(const void *addr, size_t len, int prot);
int mlock(const void *addr, size_t len);
int madvise(void *addr, size_t length, int advice);
void *mremap(void *old_address, size_t old_size, size_t new_size, int flags, ...);
int remap_file_pages(void *addr, size_t size, int prot, ssize_t pgoff, int flags);
```

这些函数在不同场景下分配、释放和管理内存。举例来说：

- `mprotect()` 设置内存保护权限，`mlock()` 和 `munlock()` 锁定和解锁内存防止交换。
- `mremap()` 重新映射内存区域，适用于动态增长的内存需求。

#### 示例解析：`malloc()` 内存分配的延迟行为

以下代码示例说明了 `malloc()` 分配和物理内存分配的实际差异：

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int func1() {
    char *p = malloc(100);
}

int func2() {
    char *p = malloc(100);
    memset(p, 0x55, 100);
}
```

- **`func1()`**：调用 `malloc(100)` 只是分配了虚拟地址空间，但并未实际分配物理内存。内核通常会在内存首次被访问时才分配物理页，这种策略称为“按需分配”。
- **`func2()`**：调用 `malloc(100)` 后立即使用 `memset()` 初始化该内存块。这时内核会实际分配物理内存，因为 `memset()` 访问了该地址空间。

通过这些函数，程序可以灵活地管理内存，但为了优化性能和资源利用率，需要理解这些 API 的工作原理和具体内核实现。例如，按需分配可以节省物理内存，尤其是在分配大内存块而仅使用部分的情况下。

### 9.2.3 从内存布局图角度看内存管理

在深入理解 Linux 系统内存管理之前，绘制并理解内存布局图非常重要。Linux 系统将虚拟地址空间划分为用户空间和内核空间，内核空间由不同的区域组成，分别承载不同的功能。以下是 ARM64 架构下 Linux 5.4 内核的典型内存布局，内存管理的核心区域如下：

#### 1. 虚拟地址空间划分

- ==**用户空间**：虚拟地址范围 `0x0000000000000000` 至 `0x0000ffffffffffff `，供用户进程使用。==
- ==**内核空间**：虚拟地址范围 `0xffff000000000000` 至 `0xffffffffffffffff`，供内核使用。==

#### 2. 内核空间布局

在 ARM64 架构上，Linux 内核的虚拟地址布局包括如下区域：

- **Modules 区域** (`0xffff000008000000` 至 `0xffff000010000000`)：大小 128 MB，加载内核模块的区域。
- ==**vmalloc 区域** (`0xffff000010000000` 至 `0xffff7dffbff0000`)：大小约 129 TB，供内核动态分配大块虚拟内存，如设备映射或内核模块使用。==
- **固定映射区域 (fixed)** (`0xffff7dfffe7f9000` 至 `0xffff7dfffeffff00`)：大小 4 KB，用于映射少量物理地址固定的内存，如 IO 端口。
- **PCI IO 区域** (`0xffff7dffee00000` 至 `0xffff7dfffe000000`)：大小 16 MB，用于 PCI 设备的 IO 地址映射。
- **vmemmap 区域** (`0xffff7e0000000000` 至 `0xffff800000000000`)：大小 2048 GB，存放页面描述符结构，支持对物理内存的管理。
- **内存线性映射区域** (`0xffff800000000000` 至 `0xffffffffffffffff`)：大小 128 TB，用于内核直接映射物理内存，使其线性映射到内核虚拟地址空间。

### 3. 内核映像的内存布局

内核映像加载后，在内核空间中划分为以下几个段：

- **代码段 (_text 段)**：包含内核代码的可执行指令，范围从 `_text` 到 `_etext`。
- **只读数据段 (rodata 段)**：从 `_start_rodata` 到 `_end_rodata`，存储内核的只读数据。
- **初始化段 (init 段)**：从 `_init_begin` 到 `_init_end`，包含初始化代码，仅在系统启动时使用，之后会释放。
- **数据段 (data 段)**：从 `_sdata` 到 `_edata`，存储全局变量。
- **BSS 段**：从 `__bss_start` 到 `__bss_stop`，用于未初始化的全局变量和静态变量。

### 4. 内核地址的特殊符号

- ==**PAGE_OFFSET**：表示物理内存在内核空间的线性映射起始地址，在 ARM64 架构上为 `0xffff800000000000`。==
- **KIMAGE_VADDR**：表示内核映像文件映射的起始虚拟地址，通常等于 `MODULES_END` 的值。
- **kimage_voffset**：内核映像的虚拟地址和物理地址之间的偏移量。
- **PHYS_OFFSET**：物理内存的实际偏移量。不同 SoC 的物理内存起始地址可能不固定，如在 QEMU Virt 平台上，物理内存的偏移量为 `0x40000000`。

### 5. ARM64 架构下的 Linux 内存布局图示

Linux 5.4 内核在 ARM64 架构上的完整内存布局如图 9.9 所示。其主要特点如下：

- ==**线性映射区域**：从 `PAGE_OFFSET` 开始，将物理内存映射至内核空间，支持高效直接访问物理内存。==
- **vmemmap 区域**：用于页面表描述符的内存管理，方便内核追踪和管理每一页内存。
- **Modules 区域**：用于动态加载和管理内核模块。
- ==**vmalloc 区域**：用于内核动态分配虚拟内存，通常不直接映射到物理内存，而是延迟映射。==

### 6. 总结

ARM64 的 Linux 内核虚拟地址空间被细分为多个区域，每个区域都有特定的用途，帮助实现高效的内存管理。通过了解这些区域的功能和边界，能更好地理解内存分配、内核模块加载和物理内存映射等关键概念。这种内存布局适用于 Linux 多种架构，实现了在内核空间有效地管理和使用大量的物理内存。

### 9.2.4 从进程角度看内存管理

从进程的角度理解内存管理是深入掌握 Linux 系统内存操作的关键。Linux 应用程序通常以 ELF (Executable and Linkable Format) 文件格式来存储和执行。以下是 Linux 系统中进程内存管理的主要内容。

#### 1. ELF 文件结构

ELF 文件包含以下重要段（Section）：

- **代码段 (.text)**：存储编译后的机器指令。
- **数据段 (.data)**：存放已初始化的全局变量和静态变量。
- **BSS 段 (.bss)**：保存未初始化的全局变量和静态变量。

在 ELF 文件中，文件头和段头表记录了文件的基本信息和各段的偏移地址。编译并链接 ELF 文件时，会将同权限的段组织在一起，形成分段（Segment），进程加载时基于这些分段映射至进程地址空间。

#### 2. 从静态角度分析 ELF 文件

使用 `readelf` 或 `objdump` 可以查看 ELF 文件的分段。以一个简单的 C 程序为例，经过编译后生成的 ELF 文件有多个分段：

- **第一个 LOAD 分段**：只读、可执行，包含代码段、只读数据段等，映射到内存中的 `0x400000`。
- **第二个 LOAD 分段**：可读可写，包含数据段和 BSS 段，映射到 `0x47e9f8`。

这些分段在加载时会映射到进程的虚拟地址空间。

#### 3. 动态内存布局：/proc 文件系统

进程在运行时，可以通过 `/proc/<pid>/maps` 查看其地址空间映射。例如，以下是一个运行的 ELF 文件在 `/proc/<pid>/maps` 中的地址空间：

- **代码段**：如 `0x400000-0x46f000`，只读可执行。
- **数据段**：如 `0x47e000-0x48100`，可读可写。
- **堆空间**：动态分配，如 `0x272dd000-0x272ff000`。
- **VDSO 和 VVAR 段**：用于内核和进程间通信。
- **栈空间**：如 `0xffffcb6c6000-0xffffcb6e7000`，用于存放函数调用栈和局部变量。

这些映射区域在 Linux 内核中通过 `vm_area_struct` (VMA) 数据结构管理，详细记录了每个映射的虚拟地址区间、权限和属性。

#### 4. 进程的详细内存使用：/proc/<pid>/smaps

`/proc/<pid>/smaps` 提供每个 VMA 段的详细内存统计，包括物理内存页、共享/私有脏页等。例如：

- **代码段 VMA**：提供总大小、共享/私有内存页的信息，帮助理解代码段的内存使用情况。
- **堆段 VMA**：显示堆区分配的大小和实际使用情况。

#### 5. 从 test 进程的视角理解内存管理

通过上面的信息，我们可以绘制出进程的内存管理布局。图示展示了进程的虚拟地址空间中各主要部分的划分，包括内核空间的线性映射区域、模块区、用户空间的栈、堆、代码段、数据段及 mmap 区域等。

#### 总结

从进程角度看内存管理，使我们理解了 ELF 文件的加载过程、运行时的内存分段映射、以及 VMA 在内核中的组织方式。这种视角对分析进程的内存使用、优化程序内存管理、以及调试内存泄漏等问题非常有帮助。

### 9.2.5 从内核角度看内存管理

内核层的内存管理体系极为复杂，涉及多个层次的管理与优化。可以将内存管理结构分为三个层次：用户空间层、内核空间层和硬件层，形成一个分层框架来理解内核对内存的整体管理过程。

#### 1. 用户空间层

用户空间层是 Linux 内核为应用程序提供的内存管理接口。这一层通过系统调用（如 `brk`、`mmap`、`madvise` 等）向用户进程提供内存管理的基本操作。常用的用户接口包括：

- `malloc()`：分配内存块，通常在底层通过 `brk` 或 `mmap` 系统调用来实现。
- `mmap()`：直接映射文件或分配大块内存。
- `mlock()`：锁定页面，防止页面被换出到交换空间。
- `madvise()`：向内核提供内存使用建议，提高内存访问效率。

这些接口通过 libc 库函数封装，屏蔽了内核实现的复杂性。

#### 2. 内核空间层

内核空间层负责处理用户进程的内存请求，以及系统自身的内存管理。它可以进一步细分为多个子模块：

- **系统调用处理**：==内核空间层首先响应用户进程的内存请求，例如 `sys_brk`、`sys_mmap`、`sys_madvise` 等系统调用。通过这些系统调用，用户空间可以请求内存分配、释放、映射等操作。==
- **VMA 管理**：==虚拟内存区域 (VMA) 是 Linux 进程地址空间的一个逻辑区段，用于管理每个进程的内存布局。VMA 提供了页表与物理内存的映射关系，涉及的操作包括内存映射和分离、映射权限、内存保护等。==
- **缺页中断管理**：==缺页中断是 MMU 发现没有有效的物理页映射时触发的中断。内核通过缺页中断管理模块处理这些事件，将相应的页面从磁盘或其他存储介质加载到内存中。==
- **匿名页面和文件缓存页面**：匿名页面指进程的堆、栈等不对应具体文件的页面；文件缓存页面指文件系统 I/O 操作缓存的页面。文件缓存页面可以加速文件读写，提高系统的 I/O 性能。
- **页面回收**：当系统内存不足时，页面回收模块会将不常用或已被标记为可释放的页面换出到交换空间或直接释放，以腾出更多的内存空间。
- **反向映射**：反向映射（Reverse Mapping）用于追踪物理页面到虚拟地址的映射。内核可以通过反向映射找到对应的 VMA 和页表条目，从而有效管理内存。
- **slab 分配器**：==slab 分配器是 Linux 内核中用于分配小对象的内存分配器，减少了内存碎片，并支持对象的高效管理与回收。==
- **页表管理**：==页表管理是内核中的核心模块，包括用户进程的页表和内核的全局页表，负责维护虚拟地址与物理地址的映射关系。==

#### 3. 硬件层

硬件层是整个内存管理的基础。主要组件包括：

- **MMU (Memory Management Unit)**：==负责将虚拟地址转换为物理地址，实现内存的隔离与保护。==
- **TLB (Translation Lookaside Buffer)**：是一种缓存，用于加速地址转换，存储最近使用的页表项。
- **高速缓存和 DDR 内存**：为处理器提供快速的数据访问，DDR 是实际存储数据的物理内存，而缓存则可以提高内存访问速度，减少主存访问延迟。

### 总结

内核角度的内存管理是一套从顶层接口到硬件管理的多层次架构。用户通过系统调用获得内存管理的接口，而内核通过 VMA 管理、缺页中断、页面回收和页表管理等机制来分配和维护内存，并通过硬件层的 MMU 和 TLB 支持高效的地址转换。理解内核空间层的细节对于掌握 Linux 内存管理机制，以及优化系统的内存使用至关重要。



### 原文：

![image-20241021105903949](image/image-20241021105903949.png)

![image-20241021105938339](image/image-20241021105938339.png)

![image-20241021110909879](image/image-20241021110909879.png)

------

### **9.2.4 从进程角度看内存管理**

- **ELF可执行文件结构**（如图9.10）：

  - **ELF头**：描述文件属性，如版本、入口地址。
  - **代码段、数据段、BSS段**：存放程序代码、初始化数据和未初始化数据。

- **内存映射示例**：

  ```
  cat /proc/<pid>/maps
  ```

  - 显示进程的内存映射情况：

    ```
    00400000-0046f000 r-xp 00000000 00:26 52559883 test.elf
    272dd000-272ff000 rw-p 00000000 00:00 0 [heap]
    ```

  - **解释**：

    - **代码段**：可读、可执行的内存区域。
    - **堆空间**：通过`malloc()`分配的内存。
  
  ![image-20241021111138836](image/image-20241021111138836.png)
  
  ![image-20241021111201050](image/image-20241021111201050.png)
  
  ![image-20241021111211769](image/image-20241021111211769.png)
  
  ==VMA==
  
  ```
  cat /proc/pid/smaps
  ```
  
  ![image-20241021111222036](image/image-20241021111222036.png)
  
  ![image-20241021111239119](image/image-20241021111239119.png)

------

### **9.2.5 从内核角度看内存管理**

- 内存管理的三层结构

  （如图9.12）：

  1. **用户空间层**：==提供系统调用接口（如`brk`、`mmap`），由`libc`库封装为`malloc()`等函数。===
  2. 内核空间层：
     - 管理用户内存请求，如`sys_mmap`、`sys_brk`。
     - ==管理虚拟内存区域（VMA）、页表、文件缓存页面及缺页中断。==
     - ==包含内存分配器（如`slab`、伙伴系统）。==
  3. 硬件层：
     - 包括MMU、TLB（转换后备缓冲）及DDR物理内存。
  
  ![image-20241021111429038](image/image-20241021111429038.png)
  
  ![image-20241021111439768](image/image-20241021111439768.png)

------

### **总结**

本节从多个层面介绍了Linux内存管理的实现与工具。

- **Linux用户**：使用`free`命令监控内存使用情况。
- **应用开发者**：通过`malloc()`和`mmap()`管理虚拟内存。
- **进程角度**：分析ELF文件结构及进程内存布局。
- **内核层面**：负责虚拟内存管理、页表维护及缺页异常处理。

这些视角相辅相成，共同构建了Linux系统高效的内存管理体系。



