# 实验 10-1：自旋锁

## 1．实验目的

了解和熟悉自旋锁的使用。

## 2．实验要求

写一个简单的内核模块，然后测试如下功能。

 在自旋锁里面，调用 alloc_page(GFP_KERNEL)函数来分配内存，观察会发

生什么情况。

 手工创造递归死锁，观察会发生什么情况。

 手工创造 AB-BA 死锁，观察会发生什么情况。

## 3．实验步骤

下面是本实验的实验步骤。

启动 QEMU+runninglinuxkernel。

$ ./run_rlk_arm64.sh run

进入本实验的参考代码。

\# cd /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1

编译内核模块。

```
benshushu:lab1# make
make -C /lib/modules/`uname -r`/build 
M=/mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1 modules;
make[1]: Entering directory '/usr/src/linux'
 CC [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock_test.o
 LD [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock-test.o
 CC [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock_nest.o
 LD [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock-nest.o
 Building modules, stage 2.
 MODPOST 2 modules
 CC /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock-nest.mod.o
 LD [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock-nest.ko
 CC /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock-test.mod.o
 LD [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1/spinlock-test.ko
 make[1]: Leaving directory '/usr/src/linux'
```

安装内核模块。

```
benshushu:lab1# insmod spinlock-nest.ko
```

过一会，通过 dmesg 命令来查看内核日志信息，发现 rcu 已经检测到有 CPU 发

生了 stall 现象。

```
[ 556.193652] spinlock_nest: loading out-of-tree module taints kernel.
[ 577.270607] rcu: INFO: rcu_sched self-detected stall on CPU
[ 577.272198] rcu: 3-....: (5224 ticks this GP) 
idle=cc6/1/0x4000000000000002 softirq=9601/9601 fqs=2324 
[ 577.272959] rcu: (t=5251 jiffies g=24341 q=598)
[ 577.274864] Task dump for CPU 3:
[ 577.275913] lockdep_test R running task 0 938 2 0x0000002a
[ 577.277490] Call trace:
[ 577.278980] dump_backtrace+0x0/0x528
[ 577.279723] show_stack+0x24/0x30
[ 577.280414] sched_show_task+0x6f4/0x730
[ 577.280774] dump_cpu_task+0x54/0x60
[ 577.281398] rcu_dump_cpu_stacks+0x330/0x414
[ 577.281699] print_cpu_stall+0x51c/0xaf8
[ 577.282078] check_cpu_stall+0x750/0x968
[ 577.282621] rcu_pending+0x64/0x38c
[ 577.282983] rcu_check_callbacks+0x54c/0x8e4
[ 577.283448] update_process_times+0x50/0x188
[ 577.284054] tick_sched_handle+0x9c/0xb0
[ 577.284293] tick_sched_timer+0xa4/0x108
[ 577.284543] __run_hrtimer+0x7d4/0xe6c
[ 577.285361] __hrtimer_run_queues+0xac/0x124
[ 577.285818] hrtimer_interrupt+0x464/0x9d8
[ 577.286394] arch_timer_handler_virt+0x7e4/0x824
[ 577.286800] handle_percpu_devid_irq+0x4e4/0xa14
[ 577.287338] generic_handle_irq+0x4c/0x5c
[ 577.288111] __handle_domain_irq+0x180/0x234
[ 577.288502] gic_handle_irq+0x1e4/0x590
[ 577.288818] el1_irq+0xb0/0x140
[ 577.289240] queued_spin_lock_slowpath+0x4c4/0x1994
[ 577.290901] nest_lock+0x538/0x62c [spinlock_nest]
[ 577.291202] lockdep_thread+0x3c/0x60 [spinlock_nest]
[ 577.291513] kthread+0x3c0/0x3cc
```

再过一会，系统的 watchdog 也触发了 soft lockup 了。

```
[ 604.305899] watchdog: BUG: soft lockup - CPU#3 stuck for 22s! 
[lockdep_test:938]
[ 604.306999] Modules linked in: spinlock_nest(O)
[ 604.307977] CPU: 3 PID: 938 Comm: lockdep_test Kdump: loaded Tainted: G 
O 5.0.0+ #4
[ 604.308329] Hardware name: linux,dummy-virt (DT)
[ 604.308747] pstate: 20000005 (nzCv daif -PAN -UAO)
[ 604.309020] pc : queued_spin_lock_slowpath+0x494/0x1994
[ 604.309622] lr : queued_spin_lock_slowpath+0x330/0x1994
[ 604.309895] sp : ffff80001fd3f5c0
[ 604.310084] x29: ffff80001fd3f5c0 x28: 0000000000000000 
[ 604.310648] x27: 0000000000000000 x26: 0000000000000000 
[ 604.311140] x25: 0000000000000000 x24: 0000000000000000 
[ 604.311324] x23: 0000000000000000 x22: 0000000000000000
[ 604.311626] x21: 0000000000000000 x20: ffff800028441300 
[ 604.311785] x19: ffff00001018b3e0 x18: 0000000000000000 
[ 604.312155] x17: 0000000000000000 x16: 0000000000000000 
[ 604.312332] x15: 0000000000000000 x14: 00000000000c8000 
[ 604.312588] x13: 0000000000000516 x12: 0000000000000516 
[ 604.312902] x11: ffffffffffffffff x10: 00000000000009d0 
[ 604.313254] x9 : ffff000009880538 x8 : ffff800029990a30 
[ 604.313913] x7 : 0000000000000000 x6 : 0000000000000000 
[ 604.314693] x5 : 000000000002021e x4 : ffff000009882380 
[ 604.315178] x3 : 0000000000000000 x2 : ffff000009882380 
[ 604.315541] x1 : 0000000000000101 x0 : 0000000000000001 
[ 604.315893] Call trace:
[ 604.316095] queued_spin_lock_slowpath+0x494/0x1994
[ 604.316403] nest_lock+0x538/0x62c [spinlock_nest]
[ 604.316776] lockdep_thread+0x3c/0x60 [spinlock_nest]
[ 604.317427] kthread+0x3c0/0x3cc
```

4．死锁检测

要在 Linux 内核中使用 Lockdep 功能，需要打开 CONFIG_DEBUG_LOCKDEP 选

项。修改内核配置文件 arch/arm64/configs/debian _defconfig.

请在 Ubuntu 主机上修改如下文件：

```
/home/rlk/rlk/runninglinuxkernel_5.0/arch/arm64/configs/debian _defconfig
```

```
CONFIG_PROVE_LOCKING=y
CONFIG_LOCKDEP=y
CONFIG_LOCK_STAT=y
CONFIG_DEBUG_LOCKDEP=y
```

![image-20240925013451607](image/image-20240925013451607.png)

重新编译内核以及本实验的内核模块。

```
rlk@rlk:runninglinuxkernel_5.0$ ./run_debian_arm64.sh build_kernel
```

内核编译完成之后，我们还需要更新一下根文件系统。

```
rlk@rlk:runninglinuxkernel_5.0$ sudo ./run_rlk_arm64.sh update_rootfs
```

启动 QEMU+runninglinuxkernel。

```
$ ./run_rlk_arm64.sh run
```

进入本实验的参考代码。

```
\# cd /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab1
```

重新编译内核模块。

```
benshushu:lab1# make
```

加载内核模块。

```
benshushu:lab1# insmod spinlock-nest.ko 
[ 290.903214] spinlock_nest: loading out-of-tree module taints kernel.
[ 290.996309] 
[ 290.997642] ============================================
[ 290.998886] WARNING: possible recursive locking detected
[ 290.999613] 5.0.0+ #5 Tainted: G O 
[ 291.000312] --------------------------------------------
[ 291.001301] lockdep_test/2013 is trying to acquire lock:
[ 291.003450] 000000002955add6 (hack_spinA){+.+.}, at: nest_lock+0x9c/0xf8 
[spinlock_nest]
[ 291.005816] 
[ 291.005816] but task is already holding lock:
[ 291.006203] 000000002955add6 (hack_spinA){+.+.}, at: nest_lock+0x2c/0xf8 
[spinlock_nest]
[ 291.006719] 
[ 291.006719] other info that might help us debug this:
[ 291.007150] Possible unsafe locking scenario:
[ 291.007150] 
[ 291.007596] CPU0
[ 291.007797] ----
[ 291.008007] lock(hack_spinA);
[ 291.008294] lock(hack_spinA);
[ 291.009004] 
[ 291.009004] *** DEADLOCK ***
[ 291.009004] 
[ 291.009654] May be due to missing lock nesting notation
[ 291.009654] 
[ 291.010372] 1 lock held by lockdep_test/2013:
[ 291.010839] #0: 000000002955add6 (hack_spinA){+.+.}, at: 
nest_lock+0x2c/0xf8 [spinlock_nest]
[ 291.011674] 
[ 291.011674] stack backtrace:
[ 291.012373] CPU: 2 PID: 2013 Comm: lockdep_test Kdump: loaded Tainted: G 
O 5.0.0+ #5
[ 291.013015] Hardware name: linux,dummy-virt (DT)
[ 291.013835] Call trace:
[ 291.014769] dump_backtrace+0x0/0x52c
[ 291.015583] show_stack+0x24/0x30
[ 291.016316] __dump_stack+0x20/0x2c
[ 291.016904] dump_stack+0x298/0x3fc
[ 291.017285] print_deadlock_bug+0x128/0x15c
[ 291.017603] check_deadlock+0x294/0x2bc
[ 291.017878] validate_chain+0x1220/0x14d0
[ 291.018137] __lock_acquire+0xaf4/0xc18
[ 291.018436] lock_acquire+0x664/0x6b8
[ 291.018835] _raw_spin_lock+0x4c/0x98
[ 291.019141] nest_lock+0x9c/0xf8 [spinlock_nest]
[ 291.019453] lockdep_thread+0x3c/0x60 [spinlock_nest]
[ 291.019901] kthread+0x3c0/0x3cc
```

从内核日志可以看到，lockdep 已经很清晰地显示了死锁发生的路径和发生时的

函数调用的栈信息，开发者根据这些信息可以很快速地定位问题和解决问题。

## 5．实验代码

```
1 #include <linux/init.h>
2 #include <linux/module.h>
3 #include <linux/kernel.h>
4 #include <linux/kthread.h>
5 #include <linux/freezer.h>
6 #include <linux/delay.h>
7 
8 static DEFINE_SPINLOCK(hack_spinA);
9 static struct page *page;
10static struct task_struct *lock_thread;
11
12static int nest_lock(void)
13{
14 int order = 5;
15
16 spin_lock(&hack_spinA);
17 page = alloc_pages(GFP_KERNEL, order);
18 if (!page) {
19 printk("cannot alloc pages\n");
20 return -ENOMEM;
21 }
22
23 spin_lock(&hack_spinA);
24 msleep(10);
25 __free_pages(page, order);
26 spin_unlock(&hack_spinA);
27 spin_unlock(&hack_spinA);
28
29 return 0;
30}
31
32static int lockdep_thread(void *nothing)
33{
34 set_freezable();
35 set_user_nice(current, 0);
36
37 while (!kthread_should_stop()) {
38 msleep(10);
39 nest_lock();
40 }
41}
42
43static int __init my_init(void)
44{
45
46 lock_thread = kthread_run(lockdep_thread, NULL, "lockdep_test");
47 if (IS_ERR(lock_thread)) {
48 printk("create kthread fail\n");
49 return PTR_ERR(lock_thread);
50 }
51
52 return 0;
53}
54
55static void __exit my_exit(void)
56{
57 kthread_stop(lock_thread);
58}
59
60MODULE_LICENSE("GPL");
61module_init(my_init);
62module_exit(my_exit);
```

