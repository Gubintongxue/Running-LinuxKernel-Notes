# 10.2 实验 10-2：互斥锁

## 1．实验目的

了解和熟悉互斥锁的使用。

## 2．实验要求

在第 6 章的虚拟 FIFO 设备中，我们并没有考虑多个进程同时访问设备驱动的情

况，请使用互斥锁对虚拟 FIFO 设备驱动程序进行并发保护。

我们首先要思考在这个虚拟 FIFO 设备驱动中有哪些资源是共享资源或者临界资

源的。

## 3．实验步骤

### 下面是本实验的实验步骤。

### 启动 QEMU+runninglinuxkernel。

```
$ ./run_rlk_arm64.sh run
```



### 进入本实验的参考代码。

```
\# cd /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab2
```

### 编译内核模块。

```
benshushu:lab2# make
make -C /lib/modules/`uname -r`/build 
M=/mnt/rlk_lab/rlk_basic/chapter_10_lock/lab2 modules;
make[1]: Entering directory '/usr/src/linux'
 CC [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab2/mydemodrv_fasync.o
 LD [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab2/mydemo_fasync.o
 Building modules, stage 2.
 MODPOST 1 modules
 CC /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab2/mydemo_fasync.mod.o
 LD [M] /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab2/mydemo_fasync.ko
make[1]: Leaving directory '/usr/src/linux'
```

### 安装内核模块。

```
benshushu:lab2# insmod mydemo_fasync.ko 
[ 2835.649964] mydemo_fasync: loading out-of-tree module taints kernel.
[ 2835.745324] my_class mydemo:249:0: create device: 249:0
[ 2835.748650] mydemo_fifo=000000009a45d251
[ 2835.765567] my_class mydemo:249:1: create device: 249:1
[ 2835.768338] mydemo_fifo=0000000009209bae
[ 2835.780505] my_class mydemo:249:2: create device: 249:2
[ 2835.781704] mydemo_fifo=000000007504e367
[ 2835.793733] my_class mydemo:249:3: create device: 249:3
[ 2835.796229] mydemo_fifo=000000001ddd7c22
[ 2835.801679] my_class mydemo:249:4: create device: 249:4
[ 2835.807013] mydemo_fifo=000000005753919e
[ 2835.813912] my_class mydemo:249:5: create device: 249:5
[ 2835.820797] mydemo_fifo=00000000ba6562de
[ 2835.824803] my_class mydemo:249:6: create device: 249:6
[ 2835.826146] mydemo_fifo=00000000126c6698
[ 2835.837653] my_class mydemo:249:7: create device: 249:7
[ 2835.841038] mydemo_fifo=000000001a93c49a
[ 2835.842590] succeeded register char device: mydemo_dev
benshushu:lab2#
```

![image-20240925013708245](image/image-20240925013708245.png)

你会看到创建了 8 个设备。你可以到/sys/class/my_class/目录下面看到这些设备。

![image-20240925013717728](image/image-20240925013717728.png)

我们可以看到创建了主设备号为 249 的设备。我们再来看一下/dev/目录。

![image-20240925013724808](image/image-20240925013724808.png)

发现并没有主设备为 252 的设备。

所以我们需要手工创建一个设备用来 test app。

```
#mknod /dev/mydemo0 c 249 0
```

切换到本实验的目录，然后编译 test 程序。

```
benshushu: # cd /mnt/rlk_lab/rlk_basic/chapter_10_lock/lab2

benshushu:lab2# gcc test.c -o test
```

接下来跑我们的 test 程序：

```
benshushu:lab2# ./test &
[1] 16493
[ 3122.697271] my_class mydemo:249:0: demodrv_open: major=249, minor=0, 
device=mydemo_dev0
[ 3122.711520] my_class mydemo:249:0: demodrv_fasync send SIGIO
```

然后使用 echo 命令来往/dev/mydemo0 这个设备写入字符串。

```
benshushu:lab2# echo "i am at shanghai now" > /dev/mydemo0 
[ 3171.385060] my_class mydemo:249:0: demodrv_open: major=249, minor=0, 
device=mydemo_dev0
[ 3171.404466] demodrv_write kill fasync
[ 3171.405722] my_class mydemo:249:0: demodrv_write:mydemo_dev0 pid=13608, 
actual_write =21, ppos=0, ret=0
benshushu:lab2# FIFO is not empty
[ 3171.431700] my_class mydemo:249:0: demodrv_read:mydemo_dev0, pid=16493, 
actual_readed=21, pos=0
i am at shanghai now
```

![image-20240925013807849](image/image-20240925013807849.png)

可以看到从 demodrv_read()函数把刚才写入的字符串已经读到用户空间了。

## 4．实验代码

首先我们需要在 struct mydemo_device 数据结构中添加一个 mutex 锁。

```
struct mydemo_device {
 char name[64];
 struct device *dev;
 wait_queue_head_t read_queue;
 wait_queue_head_t write_queue;
 struct kfifo mydemo_fifo;
 struct fasync_struct *fasync;
 struct mutex lock;
};
```

struct mydemo_device 数据结构用来描述每一个设备，我们这个驱动中最多可以

支持 8 个设备。因此这个 mutex 锁是每个设备一个锁。在使用 mutex 锁之前需要初始

化。

```
static int __init simple_char_init(void)
{
 ...
 for (i = 0; i < MYDEMO_MAX_DEVICES; i++) {
 device = kzalloc(sizeof(struct mydemo_device), GFP_KERNEL);
 if (!device) {
 ret = -ENOMEM;
 goto free_device;
 }
 sprintf(device->name, "%s%d", DEMO_NAME, i);
 mutex_init(&device->lock);
 device->dev = device_create(mydemo_class, NULL, MKDEV(dev, i), 
NULL, "mydemo:%d:%d", MAJOR(dev), i);
 dev_info(device->dev, "create device: %d:%d\n", MAJOR(dev), 
MINOR(i));
 mydemo_device[i] = device;
 init_waitqueue_head(&device->read_queue);
 init_waitqueue_head(&device->write_queue);
 ret = kfifo_alloc(&device->mydemo_fifo,
 MYDEMO_FIFO_SIZE,
 GFP_KERNEL);
 if (ret) {
 ret = -ENOMEM;
 goto free_kfifo;
 }
 printk("mydemo_fifo=%p\n", &device->mydemo_fifo);
 }
 ...
}
```

在 simple_char_init()函数中，为每一个设备都调用 mutex_init 函数对锁进行初始

化。

读者需要思考，究竟在什么地方需要使用 mutex 锁进行保护。

我们以 demodrv_read 函数为例。

```
static ssize_t
demodrv_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
 struct mydemo_private_data *data = file->private_data;
 struct mydemo_device *device = data->device;
 int actual_readed;
 int ret;
 if (kfifo_is_empty(&device->mydemo_fifo)) {
 if (file->f_flags & O_NONBLOCK)
 return -EAGAIN;
 dev_info(device->dev, "%s:%s pid=%d, going to sleep, %s\n", 
__func__, device->name, current->pid, data->name);
 ret = wait_event_interruptible(device->read_queue,
 !kfifo_is_empty(&device->mydemo_fifo));
 if (ret)
 return ret;
 }
 mutex_lock(&device->lock);
 ret = kfifo_to_user(&device->mydemo_fifo, buf, count, &actual_readed);
 if (ret)
 return -EIO;
 mutex_unlock(&device->lock);
 if (!kfifo_is_full(&device->mydemo_fifo)){
 wake_up_interruptible(&device->write_queue);
 kill_fasync(&device->fasync, SIGIO, POLL_OUT);
 }
 dev_info(device->dev, "%s:%s, pid=%d, actual_readed=%d, 
pos=%lld\n",__func__,
 device->name, current->pid, actual_readed, *ppos);
 return actual_readed;
}
```

什么地方需要加锁保护？我们需要考虑什么地方有可能是临界区，即有可能有其

他进程或者内核代码路径同时进入该区域，并对数据进行改写或者破坏。我们认为对

设备的 FIFO 进行读写操作时需要进行保护。