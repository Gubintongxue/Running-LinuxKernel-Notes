# 实验 9-8：OOM

## 1．实验目的

​		了解 OOM 机制实现的原理。

## 2．实验要求

​		1）编写一个简单的应用程序，这个应用程序只分配内存，不释放内存。然后不断地重复执行这个程序，直到系统的 OOM Killer 机制起作用。

​		2）分析 OOM Killer 打印的日志信息。

​		3）编写一个简单的内核模块，使用 alloc_pages()函数来不断分配内存直到触发系统的 OOM Killer 机制。

## 3．实验步骤

​		本实验有两个方案，一个是使用 test 应用程序来触发 OOM Killer，另外一个是使用内核驱动的方式。

​		（1） test 应用程序方法

## 下面是本实验的实验步骤。

### 启动 QEMU+runninglinuxkernel。

```
$ ./run_rlk_arm64.sh run
```

### 进入本实验的参考代码

```
# cd /mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_user_app
```

### 编译测试程序

```
benshushu:oom_user_app# make
cc -o oom oom.c -lpthread --static
```

### 运行 oom 程序。

```
benshushu:oom_user_app# ./oom
thread(ffff9b8935f0), allocating 10485760 bytes.
thread(ffff9b8935f0), allocating 10485760 bytes.
thread(ffff9b8935f0), allocating 10485760 bytes.
[ 1839.132019] oom invoked oom-killer: 
gfp_mask=0x6080c0(GFP_KERNEL|__GFP_ZERO), order=0, oom_score_adj=0
[ 1839.139817] CPU: 3 PID: 1743 Comm: oom Kdump: loaded Tainted: G O 
5.0.0+ #4
[ 1839.140313] Hardware name: linux,dummy-virt (DT)
[ 1839.141021] Call trace:
[ 1839.142942] dump_backtrace+0x0/0x528
[ 1839.143552] show_stack+0x24/0x30
[ 1839.143744] __dump_stack+0x20/0x2c
[ 1839.143916] dump_stack+0x25c/0x388
[ 1839.144081] dump_header+0x68/0x118
[ 1839.144357] oom_kill_process+0x41c/0xbfc
[ 1839.144623] out_of_memory+0x34c/0x390
[ 1839.144886] __alloc_pages_nodemask+0x2730/0x3338
[ 1839.145178] alloc_pages_current+0x200/0x23c
[ 1839.145573] __pte_alloc+0x54/0x6d0
[ 1839.146079] do_anonymous_page+0x98/0x189c
[ 1839.146678] handle_pte_fault+0x210/0xb80
[ 1839.146922] __handle_mm_fault+0xadc/0xb0c
[ 1839.147499] handle_mm_fault+0x734/0x830
[ 1839.148316] __do_page_fault+0xc4/0x110
[ 1839.148953] do_page_fault+0x700/0xda0
[ 1839.150888] do_translation_fault+0xd8/0xf8
[ 1839.151302] do_mem_abort+0x68/0xf0
[ 1839.151518] el0_da+0x20/0x24
[ 1839.152793] Mem-Info:
[ 1839.154442] active_anon:161605 inactive_anon:2328 isolated_anon:0
[ 1839.154442] active_file:24 inactive_file:52 isolated_file:0
[ 1839.154442] unevictable:0 dirty:0 writeback:0 unstable:0
[ 1839.154442] slab_reclaimable:3547 slab_unreclaimable:5209
[ 1839.154442] mapped:235 shmem:2361 pagetables:517 bounce:0
[ 1839.154442] free:6010 free_pcp:4 free_cma:439
[ 1839.157725] Node 0 active_anon:646420kB inactive_anon:9312kB 
active_file:96kB inactive_file:408kB unevictable:0kB isolated(anon):0kB 
isolated(file):0
kB mapped:940kB dirty:0kB writeback:0kB shmem:9444kB shmem_thp: 0kB 
shmem_pmdmapped: 0kB anon_thp: 468992kB writeback_tmp:0kB unstable:0kB 
all_unreclaim
able? no
[ 1839.160573] Node 0 DMA32 free:24040kB min:22528kB low:28160kB high:33792kB 
active_anon:646020kB inactive_anon:9312kB active_file:352kB inactive_file:
564kB unevictable:0kB writepending:0kB present:1048576kB managed:737092kB 
mlocked:0kB kernel_stack:2848kB pagetables:2068kB bounce:0kB free_pcp:288kB 
lo
cal_pcp:0kB free_cma:1756kB
[ 1839.168216] lowmem_reserve[]: 0 0 0
[ 1839.169694] Node 0 DMA32: 136*4kB (UEC) 36*8kB (UMEC) 66*16kB (UMEC) 
53*32kB (UME) 25*64kB (UMEC) 6*128kB (UMEC) 3*256kB (ME) 16*512kB (UMC) 
8*1024kB
(UMC) 0*2048kB 0*4096kB = 23104kB
[ 1839.172795] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=1048576kB
[ 1839.174331] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=32768kB
[ 1839.175271] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=2048kB
[ 1839.176390] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=64kB
[ 1839.178296] 2626 total pagecache pages
[ 1839.179135] 0 pages in swap cache
[ 1839.179830] Swap cache stats: add 0, delete 0, find 0/0
[ 1839.181189] Free swap = 0kB
[ 1839.182309] Total swap = 0kB
[ 1839.183096] 262144 pages RAM
[ 1839.183505] 0 pages HighMem/MovableOnly
[ 1839.183932] 77871 pages reserved
[ 1839.184327] 16384 pages cma reserved
[ 1839.184576] 0 pages hwpoisoned
[ 1839.186508] Tasks state (memory values in pages):
[ 1839.187246] [ pid ] uid tgid total_vm rss pgtables_bytes swapents 
oom_score_adj name
[ 1839.191613] [ 144] 0 144 8619 457 122880 0 
0 systemd-journal
[ 1839.192430] [ 158] 0 158 4473 254 61440 0 -
1000 systemd-udevd
[ 1839.193940] [ 194] 0 194 1385 53 53248 0 
0 cron
[ 1839.194609] [ 195] 0 195 54969 111 69632 0 
0 rsyslogd
[ 1839.195925] [ 201] 0 201 3753 234 73728 0 
0 systemd-logind
[ 1839.197958] [ 202] 104 202 1707 80 53248 0 -
900 dbus-daemon
[ 1839.199683] [ 211] 106 211 1508 70 53248 0 
0 avahi-daemon
[ 1839.201697] [ 214] 0 214 3087 147 65536 0 
0 wpa_supplicant
[ 1839.203853] [ 220] 106 220 1475 70 53248 0 
0 avahi-daemon
[ 1839.206194] [ 310] 0 310 624 26 45056 0 
0 agetty
[ 1839.208357] [ 312] 0 312 1936 116 57344 0 
0 login
[ 1839.210827] [ 334] 0 334 618 96 40960 0 
0 dhcpcd
[ 1839.213209] [ 391] 0 391 2263 314 53248 0 
0 dhclient
[ 1839.214602] [ 527] 101 527 22224 208 73728 0 
0 systemd-timesyn
[ 1839.217588] [ 537] 0 537 4189 297 69632 0 
0 systemd
[ 1839.218245] [ 540] 0 540 41764 650 90112 0 
0 (sd-pam)
[ 1839.219216] [ 552] 0 552 1672 358 49152 0 
0 bash
[ 1839.220070] [ 918] 0 918 3088 212 65536 0 -
1000 sshd
[ 1839.221064] [ 1739] 0 1739 217 11 36864 0 
0 oom
[ 1839.223343] [ 1740] 0 1740 186077 157517 1323008 0 
0 oom
[ 1839.227461] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,globa
l_oom,task_memcg=/user.slice/user-0.slice/session-c1.sco
pe,task=oom,pid=1740,uid=0
[ 1839.235762] Out of memory: Kill process 1740 (oom) score 856 or sacrifice 
child
[ 1839.246233] Killed process 1740 (oom) total-vm:744308kB, anonrss:630068kB, file-rss:0kB, shmem-rss:0kB
[ 1839.578099] oom_reaper: reaped process 1740 (oom), now anon-rss:0kB, filerss:0kB, shmem-rss:0kB
victim signalled: 9
```

​		上面 log 显示已经触发了 OOM。从下面这句话：

```
[ 1839.132019] oom invoked oom-killer: 

gfp_mask=0x6080c0(GFP_KERNEL|__GFP_ZERO), order=0, oom_score_adj=0
```

​		从“order=0”可以看出，系统想分配一个页面的时候就触发了 OOM，分配的掩码为：GFP_KERNEL|__GFP_ZERO。

​		读者要分析上述的 OOM 日志，可以参考《奔跑吧 linux 内核》第二版卷 1 的第6.3.3 章。

（2） 内核驱动方式

​		下面是本实验的实验步骤。

​		启动 QEMU+runninglinuxkernel。

```
$ ./run_rlk_arm64.sh run
```

​		进入本实验的参考代码。

```
 cd /mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_kernel_driver/
```

​		编译内核模块。

```
benshushu:oom_kernel_driver# make
make -C /lib/modules/`uname -r`/build 
M=/mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_kernel_driver modules;
make[1]: Entering directory '/usr/src/linux'
 CC [M] 
/mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_kernel_driver/alloc_oom.o
 LD [M] 
/mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_kernel_driver/alloc-oom.o
 Building modules, stage 2.
 MODPOST 1 modules
make[2]: Warning: File 
'/mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_kernel_driver/allocoom.mod.c' has modification time 0.0036 s in the future
 CC 
/mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_kernel_driver/allocoom.mod.o
 LD [M] 
/mnt/rlk_lab/rlk_basic/chapter_9_mm/lab8_oom/oom_kernel_driver/alloc-oom.ko
make[2]: warning: Clock skew detected. Your build may be incomplete.
make[1]: Leaving directory '/usr/src/linux'
```

安装内核模块。

```
benshushu:oom_kernel_driver# insmod alloc-oom.ko 
[ 2370.141158] insmod invoked oom-killer: gfp_mask=0x6000c0(GFP_KERNEL), 
order=0, oom_score_adj=0
[ 2370.149294] CPU: 0 PID: 2081 Comm: insmod Kdump: loaded Tainted: G 
O 5.0.0+ #4
[ 2370.150601] Hardware name: linux,dummy-virt (DT)
[ 2370.151585] Call trace:
[ 2370.152965] dump_backtrace+0x0/0x528
[ 2370.153513] show_stack+0x24/0x30
[ 2370.153684] __dump_stack+0x20/0x2c
[ 2370.153842] dump_stack+0x25c/0x388
[ 2370.154002] dump_header+0x68/0x118
[ 2370.154198] oom_kill_process+0x41c/0xbfc
[ 2370.154403] out_of_memory+0x34c/0x390
[ 2370.154571] __alloc_pages_nodemask+0x2730/0x3338
[ 2370.154772] alloc_pages_current+0x200/0x23c
[ 2370.155940] my_init+0x3c/0x1000 [alloc_oom]
[ 2370.156322] do_one_initcall+0x494/0xad8
[ 2370.156577] do_init_module+0xb4/0x2f8
[ 2370.156816] load_module+0x7fc/0xb0c
[ 2370.157347] __se_sys_finit_module+0x148/0x184
[ 2370.157565] __arm64_sys_finit_module+0x40/0x48
[ 2370.157805] __invoke_syscall+0x24/0x2c
[ 2370.158088] invoke_syscall+0xa4/0xd8
[ 2370.158291] el0_svc_common+0x100/0x1e4
[ 2370.158515] el0_svc_handler+0x418/0x444
[ 2370.158759] el0_svc+0x8/0xc
[ 2370.160864] Mem-Info:
[ 2370.162473] active_anon:4130 inactive_anon:2328 isolated_anon:22
[ 2370.162473] active_file:12 inactive_file:20 isolated_file:0
[ 2370.162473] unevictable:0 dirty:0 writeback:0 unstable:0
[ 2370.162473] slab_reclaimable:3545 slab_unreclaimable:5235
[ 2370.162473] mapped:205 shmem:2361 pagetables:210 bounce:0
[ 2370.162473] free:21800 free_pcp:422 free_cma:16215
[ 2370.167791] Node 0 active_anon:16520kB inactive_anon:9312kB 
active_file:48kB inactive_file:180kB unevictable:0kB isolated(anon):88kB 
isolated(file):0
kB mapped:820kB dirty:0kB writeback:0kB shmem:9444kB shmem_thp: 0kB 
shmem_pmdmapped: 0kB anon_thp: 0kB writeback_tmp:0kB unstable:0kB 
all_unreclaimable?
no
[ 2370.172651] Node 0 DMA32 free:87200kB min:22528kB low:28160kB high:33792kB 
active_anon:16520kB inactive_anon:9312kB active_file:48kB inactive_file:80
kB unevictable:0kB writepending:0kB present:1048576kB managed:737092kB 
mlocked:0kB kernel_stack:2624kB pagetables:840kB bounce:0kB free_pcp:1764kB 
local
_pcp:512kB free_cma:64860kB
[ 2370.179365] lowmem_reserve[]: 0 0 0
[ 2370.181324] Node 0 DMA32: 696*4kB (UMEC) 430*8kB (UMEC) 261*16kB (UMEC) 
131*32kB (UMEC) 49*64kB (MEC) 15*128kB (MC) 5*256kB (M) 4*512kB (UM) 0*1024kB
1*2048kB (C) 15*4096kB (C) = 86464kB
[ 2370.184769] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=1048576kB
[ 2370.186408] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=32768kB
[ 2370.187431] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=2048kB
[ 2370.187855] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 
hugepages_size=64kB
[ 2370.189774] 2442 total pagecache pages
[ 2370.190499] 0 pages in swap cache
[ 2370.190712] Swap cache stats: add 0, delete 0, find 0/0
[ 2370.191002] Free swap = 0kB
[ 2370.191228] Total swap = 0kB
[ 2370.191881] 262144 pages RAM
[ 2370.193029] 0 pages HighMem/MovableOnly
[ 2370.194026] 77871 pages reserved
[ 2370.194724] 16384 pages cma reserved
[ 2370.194966] 0 pages hwpoisoned
[ 2370.195636] Tasks state (memory values in pages):
[ 2370.195873] [ pid ] uid tgid total_vm rss pgtables_bytes swapents 
oom_score_adj name
[ 2370.198173] [ 144] 0 144 8619 455 122880 0 
0 systemd-journal
[ 2370.199158] [ 158] 0 158 4473 251 61440 0 -
1000 systemd-udevd
[ 2370.199594] [ 194] 0 194 1385 51 53248 0 
0 cron
[ 2370.200608] [ 195] 0 195 54969 153 69632 0 
0 rsyslogd
[ 2370.202048] [ 201] 0 201 3753 231 73728 0 
0 systemd-logind
[ 2370.203196] [ 202] 104 202 1707 134 53248 0 -
900 dbus-daemon
[ 2370.203749] [ 211] 106 211 1508 70 53248 0 
0 avahi-daemon
[ 2370.205218] [ 214] 0 214 3087 147 65536 0 
0 wpa_supplicant
[ 2370.206368] [ 220] 106 220 1475 70 53248 0 
0 avahi-daemon
[ 2370.207548] [ 310] 0 310 624 26 45056 0 
0 agetty
[ 2370.208947] [ 312] 0 312 1936 116 57344 0 
0 login
[ 2370.210704] [ 334] 0 334 618 95 40960 0 
0 dhcpcd
[ 2370.211333] [ 391] 0 391 2263 313 53248 0 
0 dhclient
[ 2370.211911] [ 527] 101 527 22224 231 73728 0 
0 systemd-timesyn
[ 2370.213520] [ 537] 0 537 4189 297 69632 0 
0 systemd
[ 2370.214447] [ 540] 0 540 41764 650 90112 0 
0 (sd-pam)
[ 2370.215018] [ 552] 0 552 1671 359 49152 0 
0 bash
[ 2370.215731] [ 918] 0 918 3088 212 65536 0 -
1000 sshd
[ 2370.216119] [ 2081] 0 2081 1361 71 45056 0 
0 insmod
[ 2370.217320] [ 2082] 0 2082 4473 253 61440 0 
0 systemd-udevd
[ 2370.218254] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,globa
l_oom,task_memcg=/user.slice/user-0.slice/user@0.service
,task=(sd-pam),pid=540,uid=0
[ 2370.220529] Out of memory: Kill process 540 ((sd-pam)) score 3 or 
sacrifice child
[ 2370.223740] Killed process 540 ((sd-pam)) total-vm:167056kB, anonrss:2600kB, file-rss:0kB, shmem-rss:0kB
[ 2370.399077] oom_reaper: reaped process 540 ((sd-pam)), now anon-rss:0kB, 
file-rss:0kB, shmem-rss:0kB
```

## 4．参考代码

（1）oom 测试程序代码

本程序创建了一个子进程，在子进程中根据 cpu 个数，创建了相应个数的线程，

在每个线程中不停的申请内存，直到出错为止。父进程等待子进程的结束。 最后会

触发内核的 oom 机制, 通过 dmesg 命令可以看到 oom 机制打印的信息。

```
1 #include <stdio.h>
2 #include <string.h>
3 #include <stdlib.h>
4 #include <pthread.h>
5 #include <errno.h>
6 #include <unistd.h>
7 #include <sys/mman.h>
8 #include <sys/wait.h>
9 
10 #define SIZE (10*1024*1024)
11 
12 static int alloc_mem(long int size)
13 {
14 char *s;
15 long i, pagesz = getpagesize();
16 
17 printf("thread(%lx), allocating %ld bytes.\n", (unsigned 
long)pthread_self(), size);
18 
19 s = mmap(NULL, size, PROT_READ|PROT_WRITE, 
MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
20 if (s == MAP_FAILED)
21 return errno;
22 
23 /* touch the memory */
24 for (i = 0; i < size; i+= pagesz)
25 s[i] = '\a';
26 
27 return 0;
28 }
29 
30 static void *child_alloc_thread(void *args)
31 {
32 int ret = 0;
33 
34 /* keep allocating until there is an error */
35 while (!ret)
36 alloc_mem(SIZE);
37 
38 exit(ret);
39 }
40 
41 static void child_alloc(int threads)
42 {
43 int i;
44 pthread_t *th;
45 int ret;
46 
47 th = malloc(sizeof(pthread_t) * threads);
48 if (!th) {
49 printf("malloc failed\n");
50 goto out;
51 }
52 
53 /* create threads */
54 for (i = 0; i < threads; i++) {
55 ret = pthread_create(&th[i], NULL, child_alloc_thread, 
NULL);
56 if (ret) {
57 printf("pthread_create error: %s\n", strerror(errno));
58 /* keep going if thread other than first faild to 
spawn
59 * due to lack of resource.
60 */
61 if (i == 0 || ret != EAGAIN)
62 goto out;
63 }
64 }
65 
66 /* wait for one of threads to exit whole process */
67 while(1)
68 sleep(1);
69 out:
70 exit(1);
71 }
72 
73 int main(int argc, char **argv)
74 {
75 int ncpus = -1;
76 pid_t pid;
77 int status, threads;
78 int retcode;
79 
80 ncpus = sysconf(_SC_NPROCESSORS_ONLN);
81 
82 switch(pid = fork()) {
83 case 0:
84 threads = ncpus > 1 ? ncpus : 1;
85 child_alloc(threads);
86 default:
87 break;
88 }
89 
90 printf("expected victim is %d.\n", pid);
91 waitpid(-1, &status, 0);
92 
93 if (WIFSIGNALED(status)) {
94 printf("victim signalled: %d\n", WTERMSIG(status));
95 }else if (WIFEXITED(status)) {
96 retcode = WEXITSTATUS(status);
97 printf("victim retcode: (%d) %s\n", retcode, 
strerror(retcode));
98 }else{
99 printf("victim unexpected ended\n");
100 }
101
102 return 0;
103}
（2）oom 测试驱动代码
1 #include <linux/module.h>
2 #include <linux/slab.h>
3 #include <linux/init.h>
4 #include <linux/vmalloc.h>
5 
6 static int __init my_init(void)
7 {
8 char *kbuf;
9 unsigned long order = 0;
10 size_t count = 0;
11
12 /* try __get_free_pages__ */
13 for (;;) {
14 kbuf = (char *)alloc_pages(GFP_KERNEL, order);
15 if (!kbuf) {
16 pr_err("have alloc %d pages, but continue alloc 
failed\n", count);
17 break;
18 }
19 count += (order << 1);
20 }
21
22 return 0;
23}
24
25static void __exit my_exit(void)
26{
27 pr_info("Module exit\n");
28}
29
30module_init(my_init);
31module_exit(my_exit);
32
33MODULE_AUTHOR("Ben ShuShu");
34MODULE_LICENSE("GPL v2");
```

