# 实验 12-8：使用示踪标志

## 1．实验目的

学习如何使用示踪标志（trace marker）来跟踪应用程序。

## 2．实验详解

​		有时需要跟踪用户程序和内核空间的运行情况，示踪标志可以很方便地跟踪用户程序。trace_marker 是一个文件节点，允许用户程序写入字符串。ftrace 会记录该写入动作的时间戳。

下面是一个简单实用的示踪标志例子。

```
[trace_marker_test.c]
0 #include <stdlib.h>
1 #include <stdio.h>
2 #include <string.h>
3 #include <time.h>
4 #include <sys/types.h>
5 #include <sys/stat.h>
6 #include <fcntl.h>
7 #include <sys/time.h>
8 #include <linux/unistd.h>
9 #include <stdarg.h>
10#include <unistd.h>
11#include <ctype.h>
12
13static int mark_fd = -1;
14static __thread char buff[BUFSIZ+1];
15
16static void setup_ftrace_marker(void)
17{
18 struct stat st;
19 char *files[] = {
20 "/sys/kernel/debug/tracing/trace_marker",
21 "/debug/tracing/trace_marker",
22 "/debugfs/tracing/trace_marker",
23 };
24 int ret;
25 int i;
26
27 for (i = 0; i < (sizeof(files) / sizeof(char *)); i++) {
28 ret = stat(files[i], &st);
29 if (ret >= 0)
30 goto found;
31 }
32 /* todo, check mounts system */
33 printf("canot found the sys tracing\n");
34 return;
35found:
36 mark_fd = open(files[i], O_WRONLY);
37}
38
39static void ftrace_write(const char *fmt, ...)
40{
41 va_list ap;
42 int n;
43
44 if (mark_fd < 0)
45 return;
46
47 va_start(ap, fmt);
48 n = vsnprintf(buff, BUFSIZ, fmt, ap);
49 va_end(ap);
50
51 write(mark_fd, buff, n);
52}
53
54int main()
55{
56 int count = 0;
57 setup_ftrace_marker();
58 ftrace_write("figo start program\n");
59 while (1) {
60 usleep(100*1000);
61 count++;
62 ftrace_write("figo count=%d\n", count);
63 }
64}
```

### 下面是本实验的实验步骤。

### 启动 QEMU+runninglinuxkernel。

```
$ ./run_rlk_arm64.sh run
```



### 进入本实验的参考代码。

```
# cd /mnt/rlk_lab/rlk_basic/chapter_12_debug/lab8
```



### 编译程序。

```
benshushu:lab8_trace_marker# gcc trace_marker_test.c -o trace_marker_test
```

### 接下来使用 ftrace 来跟踪用户程序的 trace marker。

```
//设置function跟踪器是不能捕捉到示踪标志的
# echo nop > /sys/kernel/debug/tracing/current_tracer

//打开ftrace才能捕捉到示踪标志
# echo 1 > /sys/kernel/debug/tracing/tracing_on

# ./trace_marker_test //运行trace_marker_test测试程序
[…] //停顿一小会儿
# echo 0 > /sys/kernel/debug/tracing/tracing_on

# cat /sys/kernel/debug/tracing/trace
```

下面是捕捉到的 trace_marker_test 测试程序写入 ftrace 的信息。

```
root@rlk:lab8_trace_marker# cat /sys/kernel/debug/tracing/trace
# tracer: nop
#
# entries-in-buffer/entries-written: 62/62 #P:10
#
# _-----=> irqs-off
# / _----=> need-resched
# | / _---=> hardirq/softirq
# || / _--=> preempt-depth
# ||| / delay
# TASK-PID CPU# |||| TIMESTAMP FUNCTION
# | | | |||| | |
 <...>-80365 [001] .... 52257.453910: tracing_mark_write: rlk start 
program
 <...>-80365 [001] .... 52257.554125: tracing_mark_write: rlk 
count=1
 <...>-80365 [001] .... 52257.655205: tracing_mark_write: rlk 
count=2
 <...>-80365 [001] .... 52257.756190: tracing_mark_write: rlk
 count=3
 <...>-80365 [001] .... 52257.856598: tracing_mark_write: rlk 
count=4
 <...>-80365 [001] .... 52257.957567: tracing_mark_write: rlk
 count=5
```

​		读者可以在捕捉示踪标志时打开其他一些示踪事件，例如调度方面的事件，这样可以观察用户程序在两个示踪标志之间的内核空间发生了什么事情。