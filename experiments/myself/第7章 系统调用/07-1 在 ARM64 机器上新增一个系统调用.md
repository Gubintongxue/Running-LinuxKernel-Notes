# 实验 7-1：在 ARM64 机器上新增一个系统调用

## 1．实验目的

通过新增一个系统调用，理解系统调用的实现过程。

## 2．实验详解

​		1）在 ARM 64 Virt 平台上新增一个系统调用，该系统调用不用传递任何参数，在该系统调用里输出当前进程的 PID 和 UID 值。

​		2）编写一个应用程序来调用这个新增的系统调用。实验要求添加的系统调用不传递任何参数，一般将 pid 和 uid 直接通过 printk 输出到 dmesg 中，但是这样非常的不优雅。该参考代码添加了一个系统调用。

```
long getpuid(pid_t *pid, uid_t *uid);
```

​		pid 和 uid 通过参数返回到用户空间。

3．实验详解

​		对于 ARM64 处理器来说，系统调用号的定义是实现在 include/uapi/asmgeneric/unistd.h 头文件中。

![image-20240923224905313](image/image-20240923224905313.png)

​		系统默认最大的系统调用个数为 295，那我们可以在系统调用最后的地方，增加一个我们新的系统调用，新的系统调用为 getpuid，号码为第 295 号。

![image-20240923224917373](image/image-20240923224917373.png)

接着我们在 arch/arm64/kernel/sys.c 文件里实现这个系统调用的回调函数。

![image-20240923225152837](image/image-20240923225152837.png)

这里的一个难点是：SYSCALL_DEFINE2 宏。读者可以看《奔跑吧 Linux 内核

入门篇》第二版第 7.1.2 章相关内容。

接下来，我们可以写一个简单的测试程序。

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
int main(int argc, char **argv)
{
long pid, uid;
int ret;
ret = (int)syscall(295, &pid, &uid);
if (ret != 0) {
printf("call getpuid failed\n");
return 1;
}
printf("call getpuid success, return pid = %d, uid = %d\n", pid, uid);
return 0;
}
```

我们的 test 测试程序也很简单，直接使用 libc 中 syscall 函数来调用我们新加的系统

调用号，即第 295 号的系统调用。

4．实验步骤

本实验的参考补丁是在：kmodules/rlk_lab/rlk_basic/chapter_7_systemcall/lab1 目录打补丁。

```
$ cd /home/rlk/rlk/runninglinuxkernel_5.0
$ git am kmodules/rlk_lab/rlk_basic/chapter_7_systemcall/lab1/0001-add-new-syscall.patch
```

编译内核。

```
$ ./run_rlk_arm64.sh build_kernel
```

启动 runninglinuxkernel。

```
$ ./run_rlk_arm64.sh run
```

编译和运行测试程序。

```
benshushu:# cd /mnt/rlk_lab/rlk_basic/chapter_7_systemcall/lab1/
benshushu:lab1# gcc test_getpuid_syscall.c -o test_getpuid_syscall
benshushu:lab1# ./test_getpuid_syscall
```

![image-20240924010542857](image/image-20240924010542857.png)